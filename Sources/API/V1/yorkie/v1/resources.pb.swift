// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: yorkie/v1/resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///
/// Copyright 2022 The Yorkie Authors. All rights reserved.
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Yorkie_V1_ValueType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case null // = 0
  case boolean // = 1
  case integer // = 2
  case long // = 3
  case double // = 4
  case string // = 5
  case bytes // = 6
  case date // = 7
  case jsonObject // = 8
  case jsonArray // = 9
  case text // = 10
  case integerCnt // = 11
  case longCnt // = 12
  case tree // = 13
  case UNRECOGNIZED(Int)

  init() {
    self = .null
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .null
    case 1: self = .boolean
    case 2: self = .integer
    case 3: self = .long
    case 4: self = .double
    case 5: self = .string
    case 6: self = .bytes
    case 7: self = .date
    case 8: self = .jsonObject
    case 9: self = .jsonArray
    case 10: self = .text
    case 11: self = .integerCnt
    case 12: self = .longCnt
    case 13: self = .tree
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .null: return 0
    case .boolean: return 1
    case .integer: return 2
    case .long: return 3
    case .double: return 4
    case .string: return 5
    case .bytes: return 6
    case .date: return 7
    case .jsonObject: return 8
    case .jsonArray: return 9
    case .text: return 10
    case .integerCnt: return 11
    case .longCnt: return 12
    case .tree: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Yorkie_V1_ValueType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Yorkie_V1_ValueType] = [
    .null,
    .boolean,
    .integer,
    .long,
    .double,
    .string,
    .bytes,
    .date,
    .jsonObject,
    .jsonArray,
    .text,
    .integerCnt,
    .longCnt,
    .tree,
  ]
}

#endif  // swift(>=4.2)

enum Yorkie_V1_DocEventType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case documentChanged // = 0
  case documentWatched // = 1
  case documentUnwatched // = 2
  case documentBroadcast // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .documentChanged
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .documentChanged
    case 1: self = .documentWatched
    case 2: self = .documentUnwatched
    case 3: self = .documentBroadcast
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .documentChanged: return 0
    case .documentWatched: return 1
    case .documentUnwatched: return 2
    case .documentBroadcast: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Yorkie_V1_DocEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Yorkie_V1_DocEventType] = [
    .documentChanged,
    .documentWatched,
    .documentUnwatched,
    .documentBroadcast,
  ]
}

#endif  // swift(>=4.2)

//////////////////////////////////////////
/// Messages for Snapshot               //
//////////////////////////////////////////
struct Yorkie_V1_Snapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var root: Yorkie_V1_JSONElement {
    get {return _root ?? Yorkie_V1_JSONElement()}
    set {_root = newValue}
  }
  /// Returns true if `root` has been explicitly set.
  var hasRoot: Bool {return self._root != nil}
  /// Clears the value of `root`. Subsequent reads from it will return its default value.
  mutating func clearRoot() {self._root = nil}

  var presences: Dictionary<String,Yorkie_V1_Presence> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _root: Yorkie_V1_JSONElement? = nil
}

/// ChangePack is a message that contains all changes that occurred in a document.
/// It is used to synchronize changes between clients and servers.
struct Yorkie_V1_ChangePack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var documentKey: String = String()

  var checkpoint: Yorkie_V1_Checkpoint {
    get {return _checkpoint ?? Yorkie_V1_Checkpoint()}
    set {_checkpoint = newValue}
  }
  /// Returns true if `checkpoint` has been explicitly set.
  var hasCheckpoint: Bool {return self._checkpoint != nil}
  /// Clears the value of `checkpoint`. Subsequent reads from it will return its default value.
  mutating func clearCheckpoint() {self._checkpoint = nil}

  var snapshot: Data = Data()

  var changes: [Yorkie_V1_Change] = []

  var minSyncedTicket: Yorkie_V1_TimeTicket {
    get {return _minSyncedTicket ?? Yorkie_V1_TimeTicket()}
    set {_minSyncedTicket = newValue}
  }
  /// Returns true if `minSyncedTicket` has been explicitly set.
  var hasMinSyncedTicket: Bool {return self._minSyncedTicket != nil}
  /// Clears the value of `minSyncedTicket`. Subsequent reads from it will return its default value.
  mutating func clearMinSyncedTicket() {self._minSyncedTicket = nil}

  var isRemoved: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _checkpoint: Yorkie_V1_Checkpoint? = nil
  fileprivate var _minSyncedTicket: Yorkie_V1_TimeTicket? = nil
}

struct Yorkie_V1_Change {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Yorkie_V1_ChangeID {
    get {return _id ?? Yorkie_V1_ChangeID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var message: String = String()

  var operations: [Yorkie_V1_Operation] = []

  var presenceChange: Yorkie_V1_PresenceChange {
    get {return _presenceChange ?? Yorkie_V1_PresenceChange()}
    set {_presenceChange = newValue}
  }
  /// Returns true if `presenceChange` has been explicitly set.
  var hasPresenceChange: Bool {return self._presenceChange != nil}
  /// Clears the value of `presenceChange`. Subsequent reads from it will return its default value.
  mutating func clearPresenceChange() {self._presenceChange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Yorkie_V1_ChangeID? = nil
  fileprivate var _presenceChange: Yorkie_V1_PresenceChange? = nil
}

struct Yorkie_V1_ChangeID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var clientSeq: UInt32 = 0

  var serverSeq: Int64 = 0

  var lamport: Int64 = 0

  var actorID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Yorkie_V1_Operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var body: Yorkie_V1_Operation.OneOf_Body? = nil

  var set: Yorkie_V1_Operation.Set {
    get {
      if case .set(let v)? = body {return v}
      return Yorkie_V1_Operation.Set()
    }
    set {body = .set(newValue)}
  }

  var add: Yorkie_V1_Operation.Add {
    get {
      if case .add(let v)? = body {return v}
      return Yorkie_V1_Operation.Add()
    }
    set {body = .add(newValue)}
  }

  var move: Yorkie_V1_Operation.Move {
    get {
      if case .move(let v)? = body {return v}
      return Yorkie_V1_Operation.Move()
    }
    set {body = .move(newValue)}
  }

  var remove: Yorkie_V1_Operation.Remove {
    get {
      if case .remove(let v)? = body {return v}
      return Yorkie_V1_Operation.Remove()
    }
    set {body = .remove(newValue)}
  }

  var edit: Yorkie_V1_Operation.Edit {
    get {
      if case .edit(let v)? = body {return v}
      return Yorkie_V1_Operation.Edit()
    }
    set {body = .edit(newValue)}
  }

  var select: Yorkie_V1_Operation.Select {
    get {
      if case .select(let v)? = body {return v}
      return Yorkie_V1_Operation.Select()
    }
    set {body = .select(newValue)}
  }

  var style: Yorkie_V1_Operation.Style {
    get {
      if case .style(let v)? = body {return v}
      return Yorkie_V1_Operation.Style()
    }
    set {body = .style(newValue)}
  }

  var increase: Yorkie_V1_Operation.Increase {
    get {
      if case .increase(let v)? = body {return v}
      return Yorkie_V1_Operation.Increase()
    }
    set {body = .increase(newValue)}
  }

  var treeEdit: Yorkie_V1_Operation.TreeEdit {
    get {
      if case .treeEdit(let v)? = body {return v}
      return Yorkie_V1_Operation.TreeEdit()
    }
    set {body = .treeEdit(newValue)}
  }

  var treeStyle: Yorkie_V1_Operation.TreeStyle {
    get {
      if case .treeStyle(let v)? = body {return v}
      return Yorkie_V1_Operation.TreeStyle()
    }
    set {body = .treeStyle(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Body: Equatable {
    case set(Yorkie_V1_Operation.Set)
    case add(Yorkie_V1_Operation.Add)
    case move(Yorkie_V1_Operation.Move)
    case remove(Yorkie_V1_Operation.Remove)
    case edit(Yorkie_V1_Operation.Edit)
    case select(Yorkie_V1_Operation.Select)
    case style(Yorkie_V1_Operation.Style)
    case increase(Yorkie_V1_Operation.Increase)
    case treeEdit(Yorkie_V1_Operation.TreeEdit)
    case treeStyle(Yorkie_V1_Operation.TreeStyle)

  #if !swift(>=4.1)
    static func ==(lhs: Yorkie_V1_Operation.OneOf_Body, rhs: Yorkie_V1_Operation.OneOf_Body) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.set, .set): return {
        guard case .set(let l) = lhs, case .set(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.add, .add): return {
        guard case .add(let l) = lhs, case .add(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.move, .move): return {
        guard case .move(let l) = lhs, case .move(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.remove, .remove): return {
        guard case .remove(let l) = lhs, case .remove(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.edit, .edit): return {
        guard case .edit(let l) = lhs, case .edit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.select, .select): return {
        guard case .select(let l) = lhs, case .select(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.style, .style): return {
        guard case .style(let l) = lhs, case .style(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.increase, .increase): return {
        guard case .increase(let l) = lhs, case .increase(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.treeEdit, .treeEdit): return {
        guard case .treeEdit(let l) = lhs, case .treeEdit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.treeStyle, .treeStyle): return {
        guard case .treeStyle(let l) = lhs, case .treeStyle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Set {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return _storage._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {_uniqueStorage()._parentCreatedAt = nil}

    var key: String {
      get {return _storage._key}
      set {_uniqueStorage()._key = newValue}
    }

    var value: Yorkie_V1_JSONElementSimple {
      get {return _storage._value ?? Yorkie_V1_JSONElementSimple()}
      set {_uniqueStorage()._value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return _storage._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {_uniqueStorage()._value = nil}

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _storage._executedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return _storage._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {_uniqueStorage()._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Add {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return _storage._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {_uniqueStorage()._parentCreatedAt = nil}

    var prevCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._prevCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._prevCreatedAt = newValue}
    }
    /// Returns true if `prevCreatedAt` has been explicitly set.
    var hasPrevCreatedAt: Bool {return _storage._prevCreatedAt != nil}
    /// Clears the value of `prevCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearPrevCreatedAt() {_uniqueStorage()._prevCreatedAt = nil}

    var value: Yorkie_V1_JSONElementSimple {
      get {return _storage._value ?? Yorkie_V1_JSONElementSimple()}
      set {_uniqueStorage()._value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return _storage._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {_uniqueStorage()._value = nil}

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _storage._executedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return _storage._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {_uniqueStorage()._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Move {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return self._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {self._parentCreatedAt = nil}

    var prevCreatedAt: Yorkie_V1_TimeTicket {
      get {return _prevCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_prevCreatedAt = newValue}
    }
    /// Returns true if `prevCreatedAt` has been explicitly set.
    var hasPrevCreatedAt: Bool {return self._prevCreatedAt != nil}
    /// Clears the value of `prevCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearPrevCreatedAt() {self._prevCreatedAt = nil}

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _executedAt ?? Yorkie_V1_TimeTicket()}
      set {_executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return self._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {self._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _prevCreatedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _executedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct Remove {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return self._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {self._parentCreatedAt = nil}

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _executedAt ?? Yorkie_V1_TimeTicket()}
      set {_executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return self._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {self._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _executedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct Edit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return _storage._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {_uniqueStorage()._parentCreatedAt = nil}

    var from: Yorkie_V1_TextNodePos {
      get {return _storage._from ?? Yorkie_V1_TextNodePos()}
      set {_uniqueStorage()._from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool {return _storage._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() {_uniqueStorage()._from = nil}

    var to: Yorkie_V1_TextNodePos {
      get {return _storage._to ?? Yorkie_V1_TextNodePos()}
      set {_uniqueStorage()._to = newValue}
    }
    /// Returns true if `to` has been explicitly set.
    var hasTo: Bool {return _storage._to != nil}
    /// Clears the value of `to`. Subsequent reads from it will return its default value.
    mutating func clearTo() {_uniqueStorage()._to = nil}

    var createdAtMapByActor: Dictionary<String,Yorkie_V1_TimeTicket> {
      get {return _storage._createdAtMapByActor}
      set {_uniqueStorage()._createdAtMapByActor = newValue}
    }

    var content: String {
      get {return _storage._content}
      set {_uniqueStorage()._content = newValue}
    }

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _storage._executedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return _storage._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {_uniqueStorage()._executedAt = nil}

    var attributes: Dictionary<String,String> {
      get {return _storage._attributes}
      set {_uniqueStorage()._attributes = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// NOTE(hackerwins): Select Operation is not used in the current version.
  /// In the previous version, it was used to represent selection of Text.
  /// However, it has been replaced by Presence now. It is retained for backward
  /// compatibility purposes.
  struct Select {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return self._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {self._parentCreatedAt = nil}

    var from: Yorkie_V1_TextNodePos {
      get {return _from ?? Yorkie_V1_TextNodePos()}
      set {_from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool {return self._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() {self._from = nil}

    var to: Yorkie_V1_TextNodePos {
      get {return _to ?? Yorkie_V1_TextNodePos()}
      set {_to = newValue}
    }
    /// Returns true if `to` has been explicitly set.
    var hasTo: Bool {return self._to != nil}
    /// Clears the value of `to`. Subsequent reads from it will return its default value.
    mutating func clearTo() {self._to = nil}

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _executedAt ?? Yorkie_V1_TimeTicket()}
      set {_executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return self._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {self._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _from: Yorkie_V1_TextNodePos? = nil
    fileprivate var _to: Yorkie_V1_TextNodePos? = nil
    fileprivate var _executedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct Style {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return _storage._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {_uniqueStorage()._parentCreatedAt = nil}

    var from: Yorkie_V1_TextNodePos {
      get {return _storage._from ?? Yorkie_V1_TextNodePos()}
      set {_uniqueStorage()._from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool {return _storage._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() {_uniqueStorage()._from = nil}

    var to: Yorkie_V1_TextNodePos {
      get {return _storage._to ?? Yorkie_V1_TextNodePos()}
      set {_uniqueStorage()._to = newValue}
    }
    /// Returns true if `to` has been explicitly set.
    var hasTo: Bool {return _storage._to != nil}
    /// Clears the value of `to`. Subsequent reads from it will return its default value.
    mutating func clearTo() {_uniqueStorage()._to = nil}

    var attributes: Dictionary<String,String> {
      get {return _storage._attributes}
      set {_uniqueStorage()._attributes = newValue}
    }

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _storage._executedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return _storage._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {_uniqueStorage()._executedAt = nil}

    var createdAtMapByActor: Dictionary<String,Yorkie_V1_TimeTicket> {
      get {return _storage._createdAtMapByActor}
      set {_uniqueStorage()._createdAtMapByActor = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Increase {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return _storage._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {_uniqueStorage()._parentCreatedAt = nil}

    var value: Yorkie_V1_JSONElementSimple {
      get {return _storage._value ?? Yorkie_V1_JSONElementSimple()}
      set {_uniqueStorage()._value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return _storage._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {_uniqueStorage()._value = nil}

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _storage._executedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return _storage._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {_uniqueStorage()._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct TreeEdit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return _storage._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {_uniqueStorage()._parentCreatedAt = nil}

    var from: Yorkie_V1_TreePos {
      get {return _storage._from ?? Yorkie_V1_TreePos()}
      set {_uniqueStorage()._from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool {return _storage._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() {_uniqueStorage()._from = nil}

    var to: Yorkie_V1_TreePos {
      get {return _storage._to ?? Yorkie_V1_TreePos()}
      set {_uniqueStorage()._to = newValue}
    }
    /// Returns true if `to` has been explicitly set.
    var hasTo: Bool {return _storage._to != nil}
    /// Clears the value of `to`. Subsequent reads from it will return its default value.
    mutating func clearTo() {_uniqueStorage()._to = nil}

    var createdAtMapByActor: Dictionary<String,Yorkie_V1_TimeTicket> {
      get {return _storage._createdAtMapByActor}
      set {_uniqueStorage()._createdAtMapByActor = newValue}
    }

    var contents: [Yorkie_V1_TreeNodes] {
      get {return _storage._contents}
      set {_uniqueStorage()._contents = newValue}
    }

    var splitLevel: Int32 {
      get {return _storage._splitLevel}
      set {_uniqueStorage()._splitLevel = newValue}
    }

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _storage._executedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return _storage._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {_uniqueStorage()._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct TreeStyle {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return _storage._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {_uniqueStorage()._parentCreatedAt = nil}

    var from: Yorkie_V1_TreePos {
      get {return _storage._from ?? Yorkie_V1_TreePos()}
      set {_uniqueStorage()._from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool {return _storage._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() {_uniqueStorage()._from = nil}

    var to: Yorkie_V1_TreePos {
      get {return _storage._to ?? Yorkie_V1_TreePos()}
      set {_uniqueStorage()._to = newValue}
    }
    /// Returns true if `to` has been explicitly set.
    var hasTo: Bool {return _storage._to != nil}
    /// Clears the value of `to`. Subsequent reads from it will return its default value.
    mutating func clearTo() {_uniqueStorage()._to = nil}

    var attributes: Dictionary<String,String> {
      get {return _storage._attributes}
      set {_uniqueStorage()._attributes = newValue}
    }

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _storage._executedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return _storage._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {_uniqueStorage()._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct Yorkie_V1_JSONElementSimple {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var createdAt: Yorkie_V1_TimeTicket {
    get {return _createdAt ?? Yorkie_V1_TimeTicket()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var movedAt: Yorkie_V1_TimeTicket {
    get {return _movedAt ?? Yorkie_V1_TimeTicket()}
    set {_movedAt = newValue}
  }
  /// Returns true if `movedAt` has been explicitly set.
  var hasMovedAt: Bool {return self._movedAt != nil}
  /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
  mutating func clearMovedAt() {self._movedAt = nil}

  var removedAt: Yorkie_V1_TimeTicket {
    get {return _removedAt ?? Yorkie_V1_TimeTicket()}
    set {_removedAt = newValue}
  }
  /// Returns true if `removedAt` has been explicitly set.
  var hasRemovedAt: Bool {return self._removedAt != nil}
  /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
  mutating func clearRemovedAt() {self._removedAt = nil}

  var type: Yorkie_V1_ValueType = .null

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
  fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
  fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
}

struct Yorkie_V1_JSONElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var body: Yorkie_V1_JSONElement.OneOf_Body? = nil

  var jsonObject: Yorkie_V1_JSONElement.JSONObject {
    get {
      if case .jsonObject(let v)? = body {return v}
      return Yorkie_V1_JSONElement.JSONObject()
    }
    set {body = .jsonObject(newValue)}
  }

  var jsonArray: Yorkie_V1_JSONElement.JSONArray {
    get {
      if case .jsonArray(let v)? = body {return v}
      return Yorkie_V1_JSONElement.JSONArray()
    }
    set {body = .jsonArray(newValue)}
  }

  var primitive: Yorkie_V1_JSONElement.Primitive {
    get {
      if case .primitive(let v)? = body {return v}
      return Yorkie_V1_JSONElement.Primitive()
    }
    set {body = .primitive(newValue)}
  }

  var text: Yorkie_V1_JSONElement.Text {
    get {
      if case .text(let v)? = body {return v}
      return Yorkie_V1_JSONElement.Text()
    }
    set {body = .text(newValue)}
  }

  var counter: Yorkie_V1_JSONElement.Counter {
    get {
      if case .counter(let v)? = body {return v}
      return Yorkie_V1_JSONElement.Counter()
    }
    set {body = .counter(newValue)}
  }

  var tree: Yorkie_V1_JSONElement.Tree {
    get {
      if case .tree(let v)? = body {return v}
      return Yorkie_V1_JSONElement.Tree()
    }
    set {body = .tree(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Body: Equatable {
    case jsonObject(Yorkie_V1_JSONElement.JSONObject)
    case jsonArray(Yorkie_V1_JSONElement.JSONArray)
    case primitive(Yorkie_V1_JSONElement.Primitive)
    case text(Yorkie_V1_JSONElement.Text)
    case counter(Yorkie_V1_JSONElement.Counter)
    case tree(Yorkie_V1_JSONElement.Tree)

  #if !swift(>=4.1)
    static func ==(lhs: Yorkie_V1_JSONElement.OneOf_Body, rhs: Yorkie_V1_JSONElement.OneOf_Body) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.jsonObject, .jsonObject): return {
        guard case .jsonObject(let l) = lhs, case .jsonObject(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.jsonArray, .jsonArray): return {
        guard case .jsonArray(let l) = lhs, case .jsonArray(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.primitive, .primitive): return {
        guard case .primitive(let l) = lhs, case .primitive(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.counter, .counter): return {
        guard case .counter(let l) = lhs, case .counter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tree, .tree): return {
        guard case .tree(let l) = lhs, case .tree(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct JSONObject {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodes: [Yorkie_V1_RHTNode] = []

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var movedAt: Yorkie_V1_TimeTicket {
      get {return _movedAt ?? Yorkie_V1_TimeTicket()}
      set {_movedAt = newValue}
    }
    /// Returns true if `movedAt` has been explicitly set.
    var hasMovedAt: Bool {return self._movedAt != nil}
    /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
    mutating func clearMovedAt() {self._movedAt = nil}

    var removedAt: Yorkie_V1_TimeTicket {
      get {return _removedAt ?? Yorkie_V1_TimeTicket()}
      set {_removedAt = newValue}
    }
    /// Returns true if `removedAt` has been explicitly set.
    var hasRemovedAt: Bool {return self._removedAt != nil}
    /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
    mutating func clearRemovedAt() {self._removedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct JSONArray {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodes: [Yorkie_V1_RGANode] = []

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var movedAt: Yorkie_V1_TimeTicket {
      get {return _movedAt ?? Yorkie_V1_TimeTicket()}
      set {_movedAt = newValue}
    }
    /// Returns true if `movedAt` has been explicitly set.
    var hasMovedAt: Bool {return self._movedAt != nil}
    /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
    mutating func clearMovedAt() {self._movedAt = nil}

    var removedAt: Yorkie_V1_TimeTicket {
      get {return _removedAt ?? Yorkie_V1_TimeTicket()}
      set {_removedAt = newValue}
    }
    /// Returns true if `removedAt` has been explicitly set.
    var hasRemovedAt: Bool {return self._removedAt != nil}
    /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
    mutating func clearRemovedAt() {self._removedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct Primitive {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Yorkie_V1_ValueType = .null

    var value: Data = Data()

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var movedAt: Yorkie_V1_TimeTicket {
      get {return _movedAt ?? Yorkie_V1_TimeTicket()}
      set {_movedAt = newValue}
    }
    /// Returns true if `movedAt` has been explicitly set.
    var hasMovedAt: Bool {return self._movedAt != nil}
    /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
    mutating func clearMovedAt() {self._movedAt = nil}

    var removedAt: Yorkie_V1_TimeTicket {
      get {return _removedAt ?? Yorkie_V1_TimeTicket()}
      set {_removedAt = newValue}
    }
    /// Returns true if `removedAt` has been explicitly set.
    var hasRemovedAt: Bool {return self._removedAt != nil}
    /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
    mutating func clearRemovedAt() {self._removedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct Text {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodes: [Yorkie_V1_TextNode] = []

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var movedAt: Yorkie_V1_TimeTicket {
      get {return _movedAt ?? Yorkie_V1_TimeTicket()}
      set {_movedAt = newValue}
    }
    /// Returns true if `movedAt` has been explicitly set.
    var hasMovedAt: Bool {return self._movedAt != nil}
    /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
    mutating func clearMovedAt() {self._movedAt = nil}

    var removedAt: Yorkie_V1_TimeTicket {
      get {return _removedAt ?? Yorkie_V1_TimeTicket()}
      set {_removedAt = newValue}
    }
    /// Returns true if `removedAt` has been explicitly set.
    var hasRemovedAt: Bool {return self._removedAt != nil}
    /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
    mutating func clearRemovedAt() {self._removedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct Counter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Yorkie_V1_ValueType = .null

    var value: Data = Data()

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var movedAt: Yorkie_V1_TimeTicket {
      get {return _movedAt ?? Yorkie_V1_TimeTicket()}
      set {_movedAt = newValue}
    }
    /// Returns true if `movedAt` has been explicitly set.
    var hasMovedAt: Bool {return self._movedAt != nil}
    /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
    mutating func clearMovedAt() {self._movedAt = nil}

    var removedAt: Yorkie_V1_TimeTicket {
      get {return _removedAt ?? Yorkie_V1_TimeTicket()}
      set {_removedAt = newValue}
    }
    /// Returns true if `removedAt` has been explicitly set.
    var hasRemovedAt: Bool {return self._removedAt != nil}
    /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
    mutating func clearRemovedAt() {self._removedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct Tree {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodes: [Yorkie_V1_TreeNode] = []

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var movedAt: Yorkie_V1_TimeTicket {
      get {return _movedAt ?? Yorkie_V1_TimeTicket()}
      set {_movedAt = newValue}
    }
    /// Returns true if `movedAt` has been explicitly set.
    var hasMovedAt: Bool {return self._movedAt != nil}
    /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
    mutating func clearMovedAt() {self._movedAt = nil}

    var removedAt: Yorkie_V1_TimeTicket {
      get {return _removedAt ?? Yorkie_V1_TimeTicket()}
      set {_removedAt = newValue}
    }
    /// Returns true if `removedAt` has been explicitly set.
    var hasRemovedAt: Bool {return self._removedAt != nil}
    /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
    mutating func clearRemovedAt() {self._removedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  }

  init() {}
}

struct Yorkie_V1_RHTNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var element: Yorkie_V1_JSONElement {
    get {return _element ?? Yorkie_V1_JSONElement()}
    set {_element = newValue}
  }
  /// Returns true if `element` has been explicitly set.
  var hasElement: Bool {return self._element != nil}
  /// Clears the value of `element`. Subsequent reads from it will return its default value.
  mutating func clearElement() {self._element = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _element: Yorkie_V1_JSONElement? = nil
}

struct Yorkie_V1_RGANode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var next: Yorkie_V1_RGANode {
    get {return _storage._next ?? Yorkie_V1_RGANode()}
    set {_uniqueStorage()._next = newValue}
  }
  /// Returns true if `next` has been explicitly set.
  var hasNext: Bool {return _storage._next != nil}
  /// Clears the value of `next`. Subsequent reads from it will return its default value.
  mutating func clearNext() {_uniqueStorage()._next = nil}

  var element: Yorkie_V1_JSONElement {
    get {return _storage._element ?? Yorkie_V1_JSONElement()}
    set {_uniqueStorage()._element = newValue}
  }
  /// Returns true if `element` has been explicitly set.
  var hasElement: Bool {return _storage._element != nil}
  /// Clears the value of `element`. Subsequent reads from it will return its default value.
  mutating func clearElement() {_uniqueStorage()._element = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Yorkie_V1_NodeAttr {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var updatedAt: Yorkie_V1_TimeTicket {
    get {return _updatedAt ?? Yorkie_V1_TimeTicket()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updatedAt: Yorkie_V1_TimeTicket? = nil
}

struct Yorkie_V1_TextNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Yorkie_V1_TextNodeID {
    get {return _id ?? Yorkie_V1_TextNodeID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var value: String = String()

  var removedAt: Yorkie_V1_TimeTicket {
    get {return _removedAt ?? Yorkie_V1_TimeTicket()}
    set {_removedAt = newValue}
  }
  /// Returns true if `removedAt` has been explicitly set.
  var hasRemovedAt: Bool {return self._removedAt != nil}
  /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
  mutating func clearRemovedAt() {self._removedAt = nil}

  var insPrevID: Yorkie_V1_TextNodeID {
    get {return _insPrevID ?? Yorkie_V1_TextNodeID()}
    set {_insPrevID = newValue}
  }
  /// Returns true if `insPrevID` has been explicitly set.
  var hasInsPrevID: Bool {return self._insPrevID != nil}
  /// Clears the value of `insPrevID`. Subsequent reads from it will return its default value.
  mutating func clearInsPrevID() {self._insPrevID = nil}

  var attributes: Dictionary<String,Yorkie_V1_NodeAttr> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Yorkie_V1_TextNodeID? = nil
  fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  fileprivate var _insPrevID: Yorkie_V1_TextNodeID? = nil
}

struct Yorkie_V1_TextNodeID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var createdAt: Yorkie_V1_TimeTicket {
    get {return _createdAt ?? Yorkie_V1_TimeTicket()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var offset: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
}

struct Yorkie_V1_TreeNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Yorkie_V1_TreeNodeID {
    get {return _storage._id ?? Yorkie_V1_TreeNodeID()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var value: String {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  var removedAt: Yorkie_V1_TimeTicket {
    get {return _storage._removedAt ?? Yorkie_V1_TimeTicket()}
    set {_uniqueStorage()._removedAt = newValue}
  }
  /// Returns true if `removedAt` has been explicitly set.
  var hasRemovedAt: Bool {return _storage._removedAt != nil}
  /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
  mutating func clearRemovedAt() {_uniqueStorage()._removedAt = nil}

  var insPrevID: Yorkie_V1_TreeNodeID {
    get {return _storage._insPrevID ?? Yorkie_V1_TreeNodeID()}
    set {_uniqueStorage()._insPrevID = newValue}
  }
  /// Returns true if `insPrevID` has been explicitly set.
  var hasInsPrevID: Bool {return _storage._insPrevID != nil}
  /// Clears the value of `insPrevID`. Subsequent reads from it will return its default value.
  mutating func clearInsPrevID() {_uniqueStorage()._insPrevID = nil}

  var insNextID: Yorkie_V1_TreeNodeID {
    get {return _storage._insNextID ?? Yorkie_V1_TreeNodeID()}
    set {_uniqueStorage()._insNextID = newValue}
  }
  /// Returns true if `insNextID` has been explicitly set.
  var hasInsNextID: Bool {return _storage._insNextID != nil}
  /// Clears the value of `insNextID`. Subsequent reads from it will return its default value.
  mutating func clearInsNextID() {_uniqueStorage()._insNextID = nil}

  var depth: Int32 {
    get {return _storage._depth}
    set {_uniqueStorage()._depth = newValue}
  }

  var attributes: Dictionary<String,Yorkie_V1_NodeAttr> {
    get {return _storage._attributes}
    set {_uniqueStorage()._attributes = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Yorkie_V1_TreeNodes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: [Yorkie_V1_TreeNode] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Yorkie_V1_TreeNodeID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var createdAt: Yorkie_V1_TimeTicket {
    get {return _createdAt ?? Yorkie_V1_TimeTicket()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var offset: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
}

struct Yorkie_V1_TreePos {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parentID: Yorkie_V1_TreeNodeID {
    get {return _parentID ?? Yorkie_V1_TreeNodeID()}
    set {_parentID = newValue}
  }
  /// Returns true if `parentID` has been explicitly set.
  var hasParentID: Bool {return self._parentID != nil}
  /// Clears the value of `parentID`. Subsequent reads from it will return its default value.
  mutating func clearParentID() {self._parentID = nil}

  var leftSiblingID: Yorkie_V1_TreeNodeID {
    get {return _leftSiblingID ?? Yorkie_V1_TreeNodeID()}
    set {_leftSiblingID = newValue}
  }
  /// Returns true if `leftSiblingID` has been explicitly set.
  var hasLeftSiblingID: Bool {return self._leftSiblingID != nil}
  /// Clears the value of `leftSiblingID`. Subsequent reads from it will return its default value.
  mutating func clearLeftSiblingID() {self._leftSiblingID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _parentID: Yorkie_V1_TreeNodeID? = nil
  fileprivate var _leftSiblingID: Yorkie_V1_TreeNodeID? = nil
}

struct Yorkie_V1_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var username: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Yorkie_V1_Project {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var publicKey: String = String()

  var secretKey: String = String()

  var authWebhookURL: String = String()

  var authWebhookMethods: [String] = []

  var clientDeactivateThreshold: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Yorkie_V1_UpdatableProjectFields {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _name ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var authWebhookURL: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _authWebhookURL ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_authWebhookURL = newValue}
  }
  /// Returns true if `authWebhookURL` has been explicitly set.
  var hasAuthWebhookURL: Bool {return self._authWebhookURL != nil}
  /// Clears the value of `authWebhookURL`. Subsequent reads from it will return its default value.
  mutating func clearAuthWebhookURL() {self._authWebhookURL = nil}

  var authWebhookMethods: Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods {
    get {return _authWebhookMethods ?? Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods()}
    set {_authWebhookMethods = newValue}
  }
  /// Returns true if `authWebhookMethods` has been explicitly set.
  var hasAuthWebhookMethods: Bool {return self._authWebhookMethods != nil}
  /// Clears the value of `authWebhookMethods`. Subsequent reads from it will return its default value.
  mutating func clearAuthWebhookMethods() {self._authWebhookMethods = nil}

  var clientDeactivateThreshold: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _clientDeactivateThreshold ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_clientDeactivateThreshold = newValue}
  }
  /// Returns true if `clientDeactivateThreshold` has been explicitly set.
  var hasClientDeactivateThreshold: Bool {return self._clientDeactivateThreshold != nil}
  /// Clears the value of `clientDeactivateThreshold`. Subsequent reads from it will return its default value.
  mutating func clearClientDeactivateThreshold() {self._clientDeactivateThreshold = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct AuthWebhookMethods {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var methods: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _name: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _authWebhookURL: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _authWebhookMethods: Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods? = nil
  fileprivate var _clientDeactivateThreshold: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

struct Yorkie_V1_DocumentSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var key: String = String()

  var snapshot: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var accessedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _accessedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_accessedAt = newValue}
  }
  /// Returns true if `accessedAt` has been explicitly set.
  var hasAccessedAt: Bool {return self._accessedAt != nil}
  /// Clears the value of `accessedAt`. Subsequent reads from it will return its default value.
  mutating func clearAccessedAt() {self._accessedAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _accessedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Yorkie_V1_PresenceChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Yorkie_V1_PresenceChange.ChangeType = .unspecified

  var presence: Yorkie_V1_Presence {
    get {return _presence ?? Yorkie_V1_Presence()}
    set {_presence = newValue}
  }
  /// Returns true if `presence` has been explicitly set.
  var hasPresence: Bool {return self._presence != nil}
  /// Clears the value of `presence`. Subsequent reads from it will return its default value.
  mutating func clearPresence() {self._presence = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ChangeType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case put // = 1
    case delete // = 2
    case clear // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .put
      case 2: self = .delete
      case 3: self = .clear
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .put: return 1
      case .delete: return 2
      case .clear: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _presence: Yorkie_V1_Presence? = nil
}

#if swift(>=4.2)

extension Yorkie_V1_PresenceChange.ChangeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Yorkie_V1_PresenceChange.ChangeType] = [
    .unspecified,
    .put,
    .delete,
    .clear,
  ]
}

#endif  // swift(>=4.2)

struct Yorkie_V1_Presence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Yorkie_V1_Checkpoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serverSeq: Int64 = 0

  var clientSeq: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Yorkie_V1_TextNodePos {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var createdAt: Yorkie_V1_TimeTicket {
    get {return _createdAt ?? Yorkie_V1_TimeTicket()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var offset: Int32 = 0

  var relativeOffset: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
}

struct Yorkie_V1_TimeTicket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lamport: Int64 = 0

  var delimiter: UInt32 = 0

  var actorID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Yorkie_V1_DocEventBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var topic: String = String()

  var payload: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Yorkie_V1_DocEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Yorkie_V1_DocEventType = .documentChanged

  var publisher: String = String()

  var body: Yorkie_V1_DocEventBody {
    get {return _body ?? Yorkie_V1_DocEventBody()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {self._body = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _body: Yorkie_V1_DocEventBody? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Yorkie_V1_ValueType: @unchecked Sendable {}
extension Yorkie_V1_DocEventType: @unchecked Sendable {}
extension Yorkie_V1_Snapshot: @unchecked Sendable {}
extension Yorkie_V1_ChangePack: @unchecked Sendable {}
extension Yorkie_V1_Change: @unchecked Sendable {}
extension Yorkie_V1_ChangeID: @unchecked Sendable {}
extension Yorkie_V1_Operation: @unchecked Sendable {}
extension Yorkie_V1_Operation.OneOf_Body: @unchecked Sendable {}
extension Yorkie_V1_Operation.Set: @unchecked Sendable {}
extension Yorkie_V1_Operation.Add: @unchecked Sendable {}
extension Yorkie_V1_Operation.Move: @unchecked Sendable {}
extension Yorkie_V1_Operation.Remove: @unchecked Sendable {}
extension Yorkie_V1_Operation.Edit: @unchecked Sendable {}
extension Yorkie_V1_Operation.Select: @unchecked Sendable {}
extension Yorkie_V1_Operation.Style: @unchecked Sendable {}
extension Yorkie_V1_Operation.Increase: @unchecked Sendable {}
extension Yorkie_V1_Operation.TreeEdit: @unchecked Sendable {}
extension Yorkie_V1_Operation.TreeStyle: @unchecked Sendable {}
extension Yorkie_V1_JSONElementSimple: @unchecked Sendable {}
extension Yorkie_V1_JSONElement: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.OneOf_Body: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.JSONObject: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.JSONArray: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.Primitive: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.Text: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.Counter: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.Tree: @unchecked Sendable {}
extension Yorkie_V1_RHTNode: @unchecked Sendable {}
extension Yorkie_V1_RGANode: @unchecked Sendable {}
extension Yorkie_V1_NodeAttr: @unchecked Sendable {}
extension Yorkie_V1_TextNode: @unchecked Sendable {}
extension Yorkie_V1_TextNodeID: @unchecked Sendable {}
extension Yorkie_V1_TreeNode: @unchecked Sendable {}
extension Yorkie_V1_TreeNodes: @unchecked Sendable {}
extension Yorkie_V1_TreeNodeID: @unchecked Sendable {}
extension Yorkie_V1_TreePos: @unchecked Sendable {}
extension Yorkie_V1_User: @unchecked Sendable {}
extension Yorkie_V1_Project: @unchecked Sendable {}
extension Yorkie_V1_UpdatableProjectFields: @unchecked Sendable {}
extension Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods: @unchecked Sendable {}
extension Yorkie_V1_DocumentSummary: @unchecked Sendable {}
extension Yorkie_V1_PresenceChange: @unchecked Sendable {}
extension Yorkie_V1_PresenceChange.ChangeType: @unchecked Sendable {}
extension Yorkie_V1_Presence: @unchecked Sendable {}
extension Yorkie_V1_Checkpoint: @unchecked Sendable {}
extension Yorkie_V1_TextNodePos: @unchecked Sendable {}
extension Yorkie_V1_TimeTicket: @unchecked Sendable {}
extension Yorkie_V1_DocEventBody: @unchecked Sendable {}
extension Yorkie_V1_DocEvent: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "yorkie.v1"

extension Yorkie_V1_ValueType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VALUE_TYPE_NULL"),
    1: .same(proto: "VALUE_TYPE_BOOLEAN"),
    2: .same(proto: "VALUE_TYPE_INTEGER"),
    3: .same(proto: "VALUE_TYPE_LONG"),
    4: .same(proto: "VALUE_TYPE_DOUBLE"),
    5: .same(proto: "VALUE_TYPE_STRING"),
    6: .same(proto: "VALUE_TYPE_BYTES"),
    7: .same(proto: "VALUE_TYPE_DATE"),
    8: .same(proto: "VALUE_TYPE_JSON_OBJECT"),
    9: .same(proto: "VALUE_TYPE_JSON_ARRAY"),
    10: .same(proto: "VALUE_TYPE_TEXT"),
    11: .same(proto: "VALUE_TYPE_INTEGER_CNT"),
    12: .same(proto: "VALUE_TYPE_LONG_CNT"),
    13: .same(proto: "VALUE_TYPE_TREE"),
  ]
}

extension Yorkie_V1_DocEventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DOC_EVENT_TYPE_DOCUMENT_CHANGED"),
    1: .same(proto: "DOC_EVENT_TYPE_DOCUMENT_WATCHED"),
    2: .same(proto: "DOC_EVENT_TYPE_DOCUMENT_UNWATCHED"),
    3: .same(proto: "DOC_EVENT_TYPE_DOCUMENT_BROADCAST"),
  ]
}

extension Yorkie_V1_Snapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Snapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "root"),
    2: .same(proto: "presences"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._root) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_Presence>.self, value: &self.presences) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._root {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.presences.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_Presence>.self, value: self.presences, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Snapshot, rhs: Yorkie_V1_Snapshot) -> Bool {
    if lhs._root != rhs._root {return false}
    if lhs.presences != rhs.presences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_ChangePack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangePack"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "document_key"),
    2: .same(proto: "checkpoint"),
    3: .same(proto: "snapshot"),
    4: .same(proto: "changes"),
    5: .standard(proto: "min_synced_ticket"),
    6: .standard(proto: "is_removed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.documentKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._checkpoint) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.snapshot) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.changes) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._minSyncedTicket) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isRemoved) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.documentKey.isEmpty {
      try visitor.visitSingularStringField(value: self.documentKey, fieldNumber: 1)
    }
    try { if let v = self._checkpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.snapshot.isEmpty {
      try visitor.visitSingularBytesField(value: self.snapshot, fieldNumber: 3)
    }
    if !self.changes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changes, fieldNumber: 4)
    }
    try { if let v = self._minSyncedTicket {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.isRemoved != false {
      try visitor.visitSingularBoolField(value: self.isRemoved, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_ChangePack, rhs: Yorkie_V1_ChangePack) -> Bool {
    if lhs.documentKey != rhs.documentKey {return false}
    if lhs._checkpoint != rhs._checkpoint {return false}
    if lhs.snapshot != rhs.snapshot {return false}
    if lhs.changes != rhs.changes {return false}
    if lhs._minSyncedTicket != rhs._minSyncedTicket {return false}
    if lhs.isRemoved != rhs.isRemoved {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Change: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Change"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "message"),
    3: .same(proto: "operations"),
    4: .standard(proto: "presence_change"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._presenceChange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 3)
    }
    try { if let v = self._presenceChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Change, rhs: Yorkie_V1_Change) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.message != rhs.message {return false}
    if lhs.operations != rhs.operations {return false}
    if lhs._presenceChange != rhs._presenceChange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_ChangeID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_seq"),
    2: .standard(proto: "server_seq"),
    3: .same(proto: "lamport"),
    4: .standard(proto: "actor_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.clientSeq) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.serverSeq) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.lamport) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.actorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clientSeq != 0 {
      try visitor.visitSingularUInt32Field(value: self.clientSeq, fieldNumber: 1)
    }
    if self.serverSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.serverSeq, fieldNumber: 2)
    }
    if self.lamport != 0 {
      try visitor.visitSingularInt64Field(value: self.lamport, fieldNumber: 3)
    }
    if !self.actorID.isEmpty {
      try visitor.visitSingularBytesField(value: self.actorID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_ChangeID, rhs: Yorkie_V1_ChangeID) -> Bool {
    if lhs.clientSeq != rhs.clientSeq {return false}
    if lhs.serverSeq != rhs.serverSeq {return false}
    if lhs.lamport != rhs.lamport {return false}
    if lhs.actorID != rhs.actorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Operation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
    2: .same(proto: "add"),
    3: .same(proto: "move"),
    4: .same(proto: "remove"),
    5: .same(proto: "edit"),
    6: .same(proto: "select"),
    7: .same(proto: "style"),
    8: .same(proto: "increase"),
    9: .standard(proto: "tree_edit"),
    10: .standard(proto: "tree_style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Yorkie_V1_Operation.Set?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .set(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .set(v)
        }
      }()
      case 2: try {
        var v: Yorkie_V1_Operation.Add?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .add(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .add(v)
        }
      }()
      case 3: try {
        var v: Yorkie_V1_Operation.Move?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .move(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .move(v)
        }
      }()
      case 4: try {
        var v: Yorkie_V1_Operation.Remove?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .remove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .remove(v)
        }
      }()
      case 5: try {
        var v: Yorkie_V1_Operation.Edit?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .edit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .edit(v)
        }
      }()
      case 6: try {
        var v: Yorkie_V1_Operation.Select?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .select(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .select(v)
        }
      }()
      case 7: try {
        var v: Yorkie_V1_Operation.Style?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .style(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .style(v)
        }
      }()
      case 8: try {
        var v: Yorkie_V1_Operation.Increase?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .increase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .increase(v)
        }
      }()
      case 9: try {
        var v: Yorkie_V1_Operation.TreeEdit?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .treeEdit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .treeEdit(v)
        }
      }()
      case 10: try {
        var v: Yorkie_V1_Operation.TreeStyle?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .treeStyle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .treeStyle(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .set?: try {
      guard case .set(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .add?: try {
      guard case .add(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .move?: try {
      guard case .move(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .remove?: try {
      guard case .remove(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .edit?: try {
      guard case .edit(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .select?: try {
      guard case .select(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .style?: try {
      guard case .style(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .increase?: try {
      guard case .increase(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .treeEdit?: try {
      guard case .treeEdit(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .treeStyle?: try {
      guard case .treeStyle(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation, rhs: Yorkie_V1_Operation) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Set"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .same(proto: "key"),
    3: .same(proto: "value"),
    4: .standard(proto: "executed_at"),
  ]

  fileprivate class _StorageClass {
    var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _key: String = String()
    var _value: Yorkie_V1_JSONElementSimple? = nil
    var _executedAt: Yorkie_V1_TimeTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parentCreatedAt = source._parentCreatedAt
      _key = source._key
      _value = source._value
      _executedAt = source._executedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._parentCreatedAt) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._key) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._executedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._parentCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 2)
      }
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._executedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Set, rhs: Yorkie_V1_Operation.Set) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parentCreatedAt != rhs_storage._parentCreatedAt {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._executedAt != rhs_storage._executedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Add: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Add"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .standard(proto: "prev_created_at"),
    3: .same(proto: "value"),
    4: .standard(proto: "executed_at"),
  ]

  fileprivate class _StorageClass {
    var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _prevCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _value: Yorkie_V1_JSONElementSimple? = nil
    var _executedAt: Yorkie_V1_TimeTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parentCreatedAt = source._parentCreatedAt
      _prevCreatedAt = source._prevCreatedAt
      _value = source._value
      _executedAt = source._executedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._parentCreatedAt) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._prevCreatedAt) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._executedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._parentCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._prevCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._executedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Add, rhs: Yorkie_V1_Operation.Add) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parentCreatedAt != rhs_storage._parentCreatedAt {return false}
        if _storage._prevCreatedAt != rhs_storage._prevCreatedAt {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._executedAt != rhs_storage._executedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Move: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Move"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .standard(proto: "prev_created_at"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "executed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parentCreatedAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._prevCreatedAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._executedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parentCreatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._prevCreatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._executedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Move, rhs: Yorkie_V1_Operation.Move) -> Bool {
    if lhs._parentCreatedAt != rhs._parentCreatedAt {return false}
    if lhs._prevCreatedAt != rhs._prevCreatedAt {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._executedAt != rhs._executedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Remove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Remove"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "executed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parentCreatedAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._executedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parentCreatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._executedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Remove, rhs: Yorkie_V1_Operation.Remove) -> Bool {
    if lhs._parentCreatedAt != rhs._parentCreatedAt {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._executedAt != rhs._executedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Edit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Edit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "created_at_map_by_actor"),
    5: .same(proto: "content"),
    6: .standard(proto: "executed_at"),
    7: .same(proto: "attributes"),
  ]

  fileprivate class _StorageClass {
    var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _from: Yorkie_V1_TextNodePos? = nil
    var _to: Yorkie_V1_TextNodePos? = nil
    var _createdAtMapByActor: Dictionary<String,Yorkie_V1_TimeTicket> = [:]
    var _content: String = String()
    var _executedAt: Yorkie_V1_TimeTicket? = nil
    var _attributes: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parentCreatedAt = source._parentCreatedAt
      _from = source._from
      _to = source._to
      _createdAtMapByActor = source._createdAtMapByActor
      _content = source._content
      _executedAt = source._executedAt
      _attributes = source._attributes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._parentCreatedAt) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._from) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._to) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_TimeTicket>.self, value: &_storage._createdAtMapByActor) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._executedAt) }()
        case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._attributes) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._parentCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._from {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._to {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._createdAtMapByActor.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_TimeTicket>.self, value: _storage._createdAtMapByActor, fieldNumber: 4)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 5)
      }
      try { if let v = _storage._executedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._attributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._attributes, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Edit, rhs: Yorkie_V1_Operation.Edit) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parentCreatedAt != rhs_storage._parentCreatedAt {return false}
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._createdAtMapByActor != rhs_storage._createdAtMapByActor {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._executedAt != rhs_storage._executedAt {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Select: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Select"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "executed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parentCreatedAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._executedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parentCreatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._executedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Select, rhs: Yorkie_V1_Operation.Select) -> Bool {
    if lhs._parentCreatedAt != rhs._parentCreatedAt {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs._executedAt != rhs._executedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Style: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Style"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "attributes"),
    5: .standard(proto: "executed_at"),
    6: .standard(proto: "created_at_map_by_actor"),
  ]

  fileprivate class _StorageClass {
    var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _from: Yorkie_V1_TextNodePos? = nil
    var _to: Yorkie_V1_TextNodePos? = nil
    var _attributes: Dictionary<String,String> = [:]
    var _executedAt: Yorkie_V1_TimeTicket? = nil
    var _createdAtMapByActor: Dictionary<String,Yorkie_V1_TimeTicket> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parentCreatedAt = source._parentCreatedAt
      _from = source._from
      _to = source._to
      _attributes = source._attributes
      _executedAt = source._executedAt
      _createdAtMapByActor = source._createdAtMapByActor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._parentCreatedAt) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._from) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._to) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._attributes) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._executedAt) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_TimeTicket>.self, value: &_storage._createdAtMapByActor) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._parentCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._from {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._to {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._attributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._attributes, fieldNumber: 4)
      }
      try { if let v = _storage._executedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._createdAtMapByActor.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_TimeTicket>.self, value: _storage._createdAtMapByActor, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Style, rhs: Yorkie_V1_Operation.Style) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parentCreatedAt != rhs_storage._parentCreatedAt {return false}
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._executedAt != rhs_storage._executedAt {return false}
        if _storage._createdAtMapByActor != rhs_storage._createdAtMapByActor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Increase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Increase"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .same(proto: "value"),
    3: .standard(proto: "executed_at"),
  ]

  fileprivate class _StorageClass {
    var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _value: Yorkie_V1_JSONElementSimple? = nil
    var _executedAt: Yorkie_V1_TimeTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parentCreatedAt = source._parentCreatedAt
      _value = source._value
      _executedAt = source._executedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._parentCreatedAt) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._executedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._parentCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._executedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Increase, rhs: Yorkie_V1_Operation.Increase) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parentCreatedAt != rhs_storage._parentCreatedAt {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._executedAt != rhs_storage._executedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.TreeEdit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".TreeEdit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "created_at_map_by_actor"),
    5: .same(proto: "contents"),
    7: .standard(proto: "split_level"),
    6: .standard(proto: "executed_at"),
  ]

  fileprivate class _StorageClass {
    var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _from: Yorkie_V1_TreePos? = nil
    var _to: Yorkie_V1_TreePos? = nil
    var _createdAtMapByActor: Dictionary<String,Yorkie_V1_TimeTicket> = [:]
    var _contents: [Yorkie_V1_TreeNodes] = []
    var _splitLevel: Int32 = 0
    var _executedAt: Yorkie_V1_TimeTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parentCreatedAt = source._parentCreatedAt
      _from = source._from
      _to = source._to
      _createdAtMapByActor = source._createdAtMapByActor
      _contents = source._contents
      _splitLevel = source._splitLevel
      _executedAt = source._executedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._parentCreatedAt) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._from) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._to) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_TimeTicket>.self, value: &_storage._createdAtMapByActor) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._contents) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._executedAt) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._splitLevel) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._parentCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._from {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._to {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._createdAtMapByActor.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_TimeTicket>.self, value: _storage._createdAtMapByActor, fieldNumber: 4)
      }
      if !_storage._contents.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._contents, fieldNumber: 5)
      }
      try { if let v = _storage._executedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._splitLevel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._splitLevel, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.TreeEdit, rhs: Yorkie_V1_Operation.TreeEdit) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parentCreatedAt != rhs_storage._parentCreatedAt {return false}
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._createdAtMapByActor != rhs_storage._createdAtMapByActor {return false}
        if _storage._contents != rhs_storage._contents {return false}
        if _storage._splitLevel != rhs_storage._splitLevel {return false}
        if _storage._executedAt != rhs_storage._executedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.TreeStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".TreeStyle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "attributes"),
    5: .standard(proto: "executed_at"),
  ]

  fileprivate class _StorageClass {
    var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _from: Yorkie_V1_TreePos? = nil
    var _to: Yorkie_V1_TreePos? = nil
    var _attributes: Dictionary<String,String> = [:]
    var _executedAt: Yorkie_V1_TimeTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parentCreatedAt = source._parentCreatedAt
      _from = source._from
      _to = source._to
      _attributes = source._attributes
      _executedAt = source._executedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._parentCreatedAt) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._from) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._to) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._attributes) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._executedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._parentCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._from {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._to {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._attributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._attributes, fieldNumber: 4)
      }
      try { if let v = _storage._executedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.TreeStyle, rhs: Yorkie_V1_Operation.TreeStyle) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parentCreatedAt != rhs_storage._parentCreatedAt {return false}
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._executedAt != rhs_storage._executedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElementSimple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JSONElementSimple"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_at"),
    2: .standard(proto: "moved_at"),
    3: .standard(proto: "removed_at"),
    4: .same(proto: "type"),
    5: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.type != .null {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElementSimple, rhs: Yorkie_V1_JSONElementSimple) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JSONElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "json_object"),
    2: .standard(proto: "json_array"),
    3: .same(proto: "primitive"),
    5: .same(proto: "text"),
    6: .same(proto: "counter"),
    7: .same(proto: "tree"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Yorkie_V1_JSONElement.JSONObject?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .jsonObject(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .jsonObject(v)
        }
      }()
      case 2: try {
        var v: Yorkie_V1_JSONElement.JSONArray?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .jsonArray(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .jsonArray(v)
        }
      }()
      case 3: try {
        var v: Yorkie_V1_JSONElement.Primitive?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .primitive(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .primitive(v)
        }
      }()
      case 5: try {
        var v: Yorkie_V1_JSONElement.Text?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .text(v)
        }
      }()
      case 6: try {
        var v: Yorkie_V1_JSONElement.Counter?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .counter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .counter(v)
        }
      }()
      case 7: try {
        var v: Yorkie_V1_JSONElement.Tree?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .tree(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .tree(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .jsonObject?: try {
      guard case .jsonObject(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .jsonArray?: try {
      guard case .jsonArray(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .primitive?: try {
      guard case .primitive(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .text?: try {
      guard case .text(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .counter?: try {
      guard case .counter(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .tree?: try {
      guard case .tree(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement, rhs: Yorkie_V1_JSONElement) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement.JSONObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_JSONElement.protoMessageName + ".JSONObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "moved_at"),
    4: .standard(proto: "removed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement.JSONObject, rhs: Yorkie_V1_JSONElement.JSONObject) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement.JSONArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_JSONElement.protoMessageName + ".JSONArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "moved_at"),
    4: .standard(proto: "removed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement.JSONArray, rhs: Yorkie_V1_JSONElement.JSONArray) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement.Primitive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_JSONElement.protoMessageName + ".Primitive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "moved_at"),
    5: .standard(proto: "removed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .null {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement.Primitive, rhs: Yorkie_V1_JSONElement.Primitive) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_JSONElement.protoMessageName + ".Text"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "moved_at"),
    4: .standard(proto: "removed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement.Text, rhs: Yorkie_V1_JSONElement.Text) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement.Counter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_JSONElement.protoMessageName + ".Counter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "moved_at"),
    5: .standard(proto: "removed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .null {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement.Counter, rhs: Yorkie_V1_JSONElement.Counter) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement.Tree: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_JSONElement.protoMessageName + ".Tree"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "moved_at"),
    4: .standard(proto: "removed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement.Tree, rhs: Yorkie_V1_JSONElement.Tree) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_RHTNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RHTNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "element"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._element) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try { if let v = self._element {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_RHTNode, rhs: Yorkie_V1_RHTNode) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._element != rhs._element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_RGANode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RGANode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "next"),
    2: .same(proto: "element"),
  ]

  fileprivate class _StorageClass {
    var _next: Yorkie_V1_RGANode? = nil
    var _element: Yorkie_V1_JSONElement? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _next = source._next
      _element = source._element
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._next) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._element) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._next {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._element {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_RGANode, rhs: Yorkie_V1_RGANode) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._next != rhs_storage._next {return false}
        if _storage._element != rhs_storage._element {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_NodeAttr: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeAttr"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_NodeAttr, rhs: Yorkie_V1_NodeAttr) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_TextNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "value"),
    3: .standard(proto: "removed_at"),
    4: .standard(proto: "ins_prev_id"),
    5: .same(proto: "attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._insPrevID) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_NodeAttr>.self, value: &self.attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._insPrevID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_NodeAttr>.self, value: self.attributes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_TextNode, rhs: Yorkie_V1_TextNode) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.value != rhs.value {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs._insPrevID != rhs._insPrevID {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_TextNodeID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextNodeID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_at"),
    2: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_TextNodeID, rhs: Yorkie_V1_TextNodeID) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_TreeNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TreeNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "value"),
    4: .standard(proto: "removed_at"),
    5: .standard(proto: "ins_prev_id"),
    6: .standard(proto: "ins_next_id"),
    7: .same(proto: "depth"),
    8: .same(proto: "attributes"),
  ]

  fileprivate class _StorageClass {
    var _id: Yorkie_V1_TreeNodeID? = nil
    var _type: String = String()
    var _value: String = String()
    var _removedAt: Yorkie_V1_TimeTicket? = nil
    var _insPrevID: Yorkie_V1_TreeNodeID? = nil
    var _insNextID: Yorkie_V1_TreeNodeID? = nil
    var _depth: Int32 = 0
    var _attributes: Dictionary<String,Yorkie_V1_NodeAttr> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _value = source._value
      _removedAt = source._removedAt
      _insPrevID = source._insPrevID
      _insNextID = source._insNextID
      _depth = source._depth
      _attributes = source._attributes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._value) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._removedAt) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._insPrevID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._insNextID) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._depth) }()
        case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_NodeAttr>.self, value: &_storage._attributes) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 2)
      }
      if !_storage._value.isEmpty {
        try visitor.visitSingularStringField(value: _storage._value, fieldNumber: 3)
      }
      try { if let v = _storage._removedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._insPrevID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._insNextID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._depth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._depth, fieldNumber: 7)
      }
      if !_storage._attributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_NodeAttr>.self, value: _storage._attributes, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_TreeNode, rhs: Yorkie_V1_TreeNode) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._removedAt != rhs_storage._removedAt {return false}
        if _storage._insPrevID != rhs_storage._insPrevID {return false}
        if _storage._insNextID != rhs_storage._insNextID {return false}
        if _storage._depth != rhs_storage._depth {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_TreeNodes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TreeNodes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_TreeNodes, rhs: Yorkie_V1_TreeNodes) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_TreeNodeID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TreeNodeID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_at"),
    2: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_TreeNodeID, rhs: Yorkie_V1_TreeNodeID) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_TreePos: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TreePos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_id"),
    2: .standard(proto: "left_sibling_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parentID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._leftSiblingID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parentID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._leftSiblingID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_TreePos, rhs: Yorkie_V1_TreePos) -> Bool {
    if lhs._parentID != rhs._parentID {return false}
    if lhs._leftSiblingID != rhs._leftSiblingID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "username"),
    3: .standard(proto: "created_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_User, rhs: Yorkie_V1_User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.username != rhs.username {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Project: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Project"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "public_key"),
    4: .standard(proto: "secret_key"),
    5: .standard(proto: "auth_webhook_url"),
    6: .standard(proto: "auth_webhook_methods"),
    7: .standard(proto: "client_deactivate_threshold"),
    8: .standard(proto: "created_at"),
    9: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.secretKey) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authWebhookURL) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.authWebhookMethods) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.clientDeactivateThreshold) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 3)
    }
    if !self.secretKey.isEmpty {
      try visitor.visitSingularStringField(value: self.secretKey, fieldNumber: 4)
    }
    if !self.authWebhookURL.isEmpty {
      try visitor.visitSingularStringField(value: self.authWebhookURL, fieldNumber: 5)
    }
    if !self.authWebhookMethods.isEmpty {
      try visitor.visitRepeatedStringField(value: self.authWebhookMethods, fieldNumber: 6)
    }
    if !self.clientDeactivateThreshold.isEmpty {
      try visitor.visitSingularStringField(value: self.clientDeactivateThreshold, fieldNumber: 7)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Project, rhs: Yorkie_V1_Project) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.secretKey != rhs.secretKey {return false}
    if lhs.authWebhookURL != rhs.authWebhookURL {return false}
    if lhs.authWebhookMethods != rhs.authWebhookMethods {return false}
    if lhs.clientDeactivateThreshold != rhs.clientDeactivateThreshold {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_UpdatableProjectFields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdatableProjectFields"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "auth_webhook_url"),
    3: .standard(proto: "auth_webhook_methods"),
    4: .standard(proto: "client_deactivate_threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authWebhookURL) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._authWebhookMethods) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clientDeactivateThreshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authWebhookURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._authWebhookMethods {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._clientDeactivateThreshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_UpdatableProjectFields, rhs: Yorkie_V1_UpdatableProjectFields) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._authWebhookURL != rhs._authWebhookURL {return false}
    if lhs._authWebhookMethods != rhs._authWebhookMethods {return false}
    if lhs._clientDeactivateThreshold != rhs._clientDeactivateThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_UpdatableProjectFields.protoMessageName + ".AuthWebhookMethods"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "methods"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.methods) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.methods.isEmpty {
      try visitor.visitRepeatedStringField(value: self.methods, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods, rhs: Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods) -> Bool {
    if lhs.methods != rhs.methods {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_DocumentSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "key"),
    3: .same(proto: "snapshot"),
    4: .standard(proto: "created_at"),
    5: .standard(proto: "accessed_at"),
    6: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.snapshot) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._accessedAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.snapshot.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshot, fieldNumber: 3)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._accessedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_DocumentSummary, rhs: Yorkie_V1_DocumentSummary) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.key != rhs.key {return false}
    if lhs.snapshot != rhs.snapshot {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._accessedAt != rhs._accessedAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_PresenceChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PresenceChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "presence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._presence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._presence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_PresenceChange, rhs: Yorkie_V1_PresenceChange) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._presence != rhs._presence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_PresenceChange.ChangeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANGE_TYPE_UNSPECIFIED"),
    1: .same(proto: "CHANGE_TYPE_PUT"),
    2: .same(proto: "CHANGE_TYPE_DELETE"),
    3: .same(proto: "CHANGE_TYPE_CLEAR"),
  ]
}

extension Yorkie_V1_Presence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Presence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Presence, rhs: Yorkie_V1_Presence) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Checkpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Checkpoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_seq"),
    2: .standard(proto: "client_seq"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.serverSeq) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.clientSeq) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.serverSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.serverSeq, fieldNumber: 1)
    }
    if self.clientSeq != 0 {
      try visitor.visitSingularUInt32Field(value: self.clientSeq, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Checkpoint, rhs: Yorkie_V1_Checkpoint) -> Bool {
    if lhs.serverSeq != rhs.serverSeq {return false}
    if lhs.clientSeq != rhs.clientSeq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_TextNodePos: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextNodePos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_at"),
    2: .same(proto: "offset"),
    3: .standard(proto: "relative_offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.relativeOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 2)
    }
    if self.relativeOffset != 0 {
      try visitor.visitSingularInt32Field(value: self.relativeOffset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_TextNodePos, rhs: Yorkie_V1_TextNodePos) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.relativeOffset != rhs.relativeOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_TimeTicket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeTicket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lamport"),
    2: .same(proto: "delimiter"),
    3: .standard(proto: "actor_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.lamport) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.delimiter) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.actorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lamport != 0 {
      try visitor.visitSingularInt64Field(value: self.lamport, fieldNumber: 1)
    }
    if self.delimiter != 0 {
      try visitor.visitSingularUInt32Field(value: self.delimiter, fieldNumber: 2)
    }
    if !self.actorID.isEmpty {
      try visitor.visitSingularBytesField(value: self.actorID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_TimeTicket, rhs: Yorkie_V1_TimeTicket) -> Bool {
    if lhs.lamport != rhs.lamport {return false}
    if lhs.delimiter != rhs.delimiter {return false}
    if lhs.actorID != rhs.actorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_DocEventBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocEventBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_DocEventBody, rhs: Yorkie_V1_DocEventBody) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_DocEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "publisher"),
    3: .same(proto: "body"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.publisher) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .documentChanged {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.publisher.isEmpty {
      try visitor.visitSingularStringField(value: self.publisher, fieldNumber: 2)
    }
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_DocEvent, rhs: Yorkie_V1_DocEvent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.publisher != rhs.publisher {return false}
    if lhs._body != rhs._body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
