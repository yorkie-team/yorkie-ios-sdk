// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///
/// Copyright 2022 The Yorkie Authors. All rights reserved.
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Yorkie_V1_ValueType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case null // = 0
  case boolean // = 1
  case integer // = 2
  case long // = 3
  case double // = 4
  case string // = 5
  case bytes // = 6
  case date // = 7
  case jsonObject // = 8
  case jsonArray // = 9
  case text // = 10
  case richText // = 11
  case integerCnt // = 12
  case longCnt // = 13
  case doubleCnt // = 14
  case UNRECOGNIZED(Int)

  init() {
    self = .null
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .null
    case 1: self = .boolean
    case 2: self = .integer
    case 3: self = .long
    case 4: self = .double
    case 5: self = .string
    case 6: self = .bytes
    case 7: self = .date
    case 8: self = .jsonObject
    case 9: self = .jsonArray
    case 10: self = .text
    case 11: self = .richText
    case 12: self = .integerCnt
    case 13: self = .longCnt
    case 14: self = .doubleCnt
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .null: return 0
    case .boolean: return 1
    case .integer: return 2
    case .long: return 3
    case .double: return 4
    case .string: return 5
    case .bytes: return 6
    case .date: return 7
    case .jsonObject: return 8
    case .jsonArray: return 9
    case .text: return 10
    case .richText: return 11
    case .integerCnt: return 12
    case .longCnt: return 13
    case .doubleCnt: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Yorkie_V1_ValueType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Yorkie_V1_ValueType] = [
    .null,
    .boolean,
    .integer,
    .long,
    .double,
    .string,
    .bytes,
    .date,
    .jsonObject,
    .jsonArray,
    .text,
    .richText,
    .integerCnt,
    .longCnt,
    .doubleCnt,
  ]
}

#endif  // swift(>=4.2)

enum Yorkie_V1_DocEventType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case documentsChanged // = 0
  case documentsWatched // = 1
  case documentsUnwatched // = 2
  case presenceChanged // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .documentsChanged
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .documentsChanged
    case 1: self = .documentsWatched
    case 2: self = .documentsUnwatched
    case 3: self = .presenceChanged
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .documentsChanged: return 0
    case .documentsWatched: return 1
    case .documentsUnwatched: return 2
    case .presenceChanged: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Yorkie_V1_DocEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Yorkie_V1_DocEventType] = [
    .documentsChanged,
    .documentsWatched,
    .documentsUnwatched,
    .presenceChanged,
  ]
}

#endif  // swift(>=4.2)

struct Yorkie_V1_ChangePack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var documentKey: String = String()

  var checkpoint: Yorkie_V1_Checkpoint {
    get {return _checkpoint ?? Yorkie_V1_Checkpoint()}
    set {_checkpoint = newValue}
  }
  /// Returns true if `checkpoint` has been explicitly set.
  var hasCheckpoint: Bool {return self._checkpoint != nil}
  /// Clears the value of `checkpoint`. Subsequent reads from it will return its default value.
  mutating func clearCheckpoint() {self._checkpoint = nil}

  var snapshot: Data = Data()

  var changes: [Yorkie_V1_Change] = []

  var minSyncedTicket: Yorkie_V1_TimeTicket {
    get {return _minSyncedTicket ?? Yorkie_V1_TimeTicket()}
    set {_minSyncedTicket = newValue}
  }
  /// Returns true if `minSyncedTicket` has been explicitly set.
  var hasMinSyncedTicket: Bool {return self._minSyncedTicket != nil}
  /// Clears the value of `minSyncedTicket`. Subsequent reads from it will return its default value.
  mutating func clearMinSyncedTicket() {self._minSyncedTicket = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _checkpoint: Yorkie_V1_Checkpoint? = nil
  fileprivate var _minSyncedTicket: Yorkie_V1_TimeTicket? = nil
}

struct Yorkie_V1_Change {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Yorkie_V1_ChangeID {
    get {return _id ?? Yorkie_V1_ChangeID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var message: String = String()

  var operations: [Yorkie_V1_Operation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Yorkie_V1_ChangeID? = nil
}

struct Yorkie_V1_ChangeID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var clientSeq: UInt32 = 0

  var serverSeq: Int64 = 0

  var lamport: Int64 = 0

  var actorID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Yorkie_V1_Operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var body: Yorkie_V1_Operation.OneOf_Body? = nil

  var set: Yorkie_V1_Operation.Set {
    get {
      if case .set(let v)? = body {return v}
      return Yorkie_V1_Operation.Set()
    }
    set {body = .set(newValue)}
  }

  var add: Yorkie_V1_Operation.Add {
    get {
      if case .add(let v)? = body {return v}
      return Yorkie_V1_Operation.Add()
    }
    set {body = .add(newValue)}
  }

  var move: Yorkie_V1_Operation.Move {
    get {
      if case .move(let v)? = body {return v}
      return Yorkie_V1_Operation.Move()
    }
    set {body = .move(newValue)}
  }

  var remove: Yorkie_V1_Operation.Remove {
    get {
      if case .remove(let v)? = body {return v}
      return Yorkie_V1_Operation.Remove()
    }
    set {body = .remove(newValue)}
  }

  var edit: Yorkie_V1_Operation.Edit {
    get {
      if case .edit(let v)? = body {return v}
      return Yorkie_V1_Operation.Edit()
    }
    set {body = .edit(newValue)}
  }

  var select: Yorkie_V1_Operation.Select {
    get {
      if case .select(let v)? = body {return v}
      return Yorkie_V1_Operation.Select()
    }
    set {body = .select(newValue)}
  }

  var richEdit: Yorkie_V1_Operation.RichEdit {
    get {
      if case .richEdit(let v)? = body {return v}
      return Yorkie_V1_Operation.RichEdit()
    }
    set {body = .richEdit(newValue)}
  }

  var style: Yorkie_V1_Operation.Style {
    get {
      if case .style(let v)? = body {return v}
      return Yorkie_V1_Operation.Style()
    }
    set {body = .style(newValue)}
  }

  var increase: Yorkie_V1_Operation.Increase {
    get {
      if case .increase(let v)? = body {return v}
      return Yorkie_V1_Operation.Increase()
    }
    set {body = .increase(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Body: Equatable {
    case set(Yorkie_V1_Operation.Set)
    case add(Yorkie_V1_Operation.Add)
    case move(Yorkie_V1_Operation.Move)
    case remove(Yorkie_V1_Operation.Remove)
    case edit(Yorkie_V1_Operation.Edit)
    case select(Yorkie_V1_Operation.Select)
    case richEdit(Yorkie_V1_Operation.RichEdit)
    case style(Yorkie_V1_Operation.Style)
    case increase(Yorkie_V1_Operation.Increase)

  #if !swift(>=4.1)
    static func ==(lhs: Yorkie_V1_Operation.OneOf_Body, rhs: Yorkie_V1_Operation.OneOf_Body) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.set, .set): return {
        guard case .set(let l) = lhs, case .set(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.add, .add): return {
        guard case .add(let l) = lhs, case .add(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.move, .move): return {
        guard case .move(let l) = lhs, case .move(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.remove, .remove): return {
        guard case .remove(let l) = lhs, case .remove(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.edit, .edit): return {
        guard case .edit(let l) = lhs, case .edit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.select, .select): return {
        guard case .select(let l) = lhs, case .select(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.richEdit, .richEdit): return {
        guard case .richEdit(let l) = lhs, case .richEdit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.style, .style): return {
        guard case .style(let l) = lhs, case .style(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.increase, .increase): return {
        guard case .increase(let l) = lhs, case .increase(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Set {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return _storage._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {_uniqueStorage()._parentCreatedAt = nil}

    var key: String {
      get {return _storage._key}
      set {_uniqueStorage()._key = newValue}
    }

    var value: Yorkie_V1_JSONElementSimple {
      get {return _storage._value ?? Yorkie_V1_JSONElementSimple()}
      set {_uniqueStorage()._value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return _storage._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {_uniqueStorage()._value = nil}

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _storage._executedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return _storage._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {_uniqueStorage()._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Add {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return _storage._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {_uniqueStorage()._parentCreatedAt = nil}

    var prevCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._prevCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._prevCreatedAt = newValue}
    }
    /// Returns true if `prevCreatedAt` has been explicitly set.
    var hasPrevCreatedAt: Bool {return _storage._prevCreatedAt != nil}
    /// Clears the value of `prevCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearPrevCreatedAt() {_uniqueStorage()._prevCreatedAt = nil}

    var value: Yorkie_V1_JSONElementSimple {
      get {return _storage._value ?? Yorkie_V1_JSONElementSimple()}
      set {_uniqueStorage()._value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return _storage._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {_uniqueStorage()._value = nil}

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _storage._executedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return _storage._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {_uniqueStorage()._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Move {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return self._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {self._parentCreatedAt = nil}

    var prevCreatedAt: Yorkie_V1_TimeTicket {
      get {return _prevCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_prevCreatedAt = newValue}
    }
    /// Returns true if `prevCreatedAt` has been explicitly set.
    var hasPrevCreatedAt: Bool {return self._prevCreatedAt != nil}
    /// Clears the value of `prevCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearPrevCreatedAt() {self._prevCreatedAt = nil}

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _executedAt ?? Yorkie_V1_TimeTicket()}
      set {_executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return self._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {self._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _prevCreatedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _executedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct Remove {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return self._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {self._parentCreatedAt = nil}

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _executedAt ?? Yorkie_V1_TimeTicket()}
      set {_executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return self._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {self._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _executedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct Edit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return _storage._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {_uniqueStorage()._parentCreatedAt = nil}

    var from: Yorkie_V1_TextNodePos {
      get {return _storage._from ?? Yorkie_V1_TextNodePos()}
      set {_uniqueStorage()._from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool {return _storage._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() {_uniqueStorage()._from = nil}

    var to: Yorkie_V1_TextNodePos {
      get {return _storage._to ?? Yorkie_V1_TextNodePos()}
      set {_uniqueStorage()._to = newValue}
    }
    /// Returns true if `to` has been explicitly set.
    var hasTo: Bool {return _storage._to != nil}
    /// Clears the value of `to`. Subsequent reads from it will return its default value.
    mutating func clearTo() {_uniqueStorage()._to = nil}

    var createdAtMapByActor: Dictionary<String,Yorkie_V1_TimeTicket> {
      get {return _storage._createdAtMapByActor}
      set {_uniqueStorage()._createdAtMapByActor = newValue}
    }

    var content: String {
      get {return _storage._content}
      set {_uniqueStorage()._content = newValue}
    }

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _storage._executedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return _storage._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {_uniqueStorage()._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Select {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return self._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {self._parentCreatedAt = nil}

    var from: Yorkie_V1_TextNodePos {
      get {return _from ?? Yorkie_V1_TextNodePos()}
      set {_from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool {return self._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() {self._from = nil}

    var to: Yorkie_V1_TextNodePos {
      get {return _to ?? Yorkie_V1_TextNodePos()}
      set {_to = newValue}
    }
    /// Returns true if `to` has been explicitly set.
    var hasTo: Bool {return self._to != nil}
    /// Clears the value of `to`. Subsequent reads from it will return its default value.
    mutating func clearTo() {self._to = nil}

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _executedAt ?? Yorkie_V1_TimeTicket()}
      set {_executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return self._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {self._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _from: Yorkie_V1_TextNodePos? = nil
    fileprivate var _to: Yorkie_V1_TextNodePos? = nil
    fileprivate var _executedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct RichEdit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return _storage._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {_uniqueStorage()._parentCreatedAt = nil}

    var from: Yorkie_V1_TextNodePos {
      get {return _storage._from ?? Yorkie_V1_TextNodePos()}
      set {_uniqueStorage()._from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool {return _storage._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() {_uniqueStorage()._from = nil}

    var to: Yorkie_V1_TextNodePos {
      get {return _storage._to ?? Yorkie_V1_TextNodePos()}
      set {_uniqueStorage()._to = newValue}
    }
    /// Returns true if `to` has been explicitly set.
    var hasTo: Bool {return _storage._to != nil}
    /// Clears the value of `to`. Subsequent reads from it will return its default value.
    mutating func clearTo() {_uniqueStorage()._to = nil}

    var createdAtMapByActor: Dictionary<String,Yorkie_V1_TimeTicket> {
      get {return _storage._createdAtMapByActor}
      set {_uniqueStorage()._createdAtMapByActor = newValue}
    }

    var content: String {
      get {return _storage._content}
      set {_uniqueStorage()._content = newValue}
    }

    var attributes: Dictionary<String,String> {
      get {return _storage._attributes}
      set {_uniqueStorage()._attributes = newValue}
    }

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _storage._executedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return _storage._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {_uniqueStorage()._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Style {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return _storage._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {_uniqueStorage()._parentCreatedAt = nil}

    var from: Yorkie_V1_TextNodePos {
      get {return _storage._from ?? Yorkie_V1_TextNodePos()}
      set {_uniqueStorage()._from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool {return _storage._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() {_uniqueStorage()._from = nil}

    var to: Yorkie_V1_TextNodePos {
      get {return _storage._to ?? Yorkie_V1_TextNodePos()}
      set {_uniqueStorage()._to = newValue}
    }
    /// Returns true if `to` has been explicitly set.
    var hasTo: Bool {return _storage._to != nil}
    /// Clears the value of `to`. Subsequent reads from it will return its default value.
    mutating func clearTo() {_uniqueStorage()._to = nil}

    var attributes: Dictionary<String,String> {
      get {return _storage._attributes}
      set {_uniqueStorage()._attributes = newValue}
    }

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _storage._executedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return _storage._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {_uniqueStorage()._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Increase {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parentCreatedAt: Yorkie_V1_TimeTicket {
      get {return _storage._parentCreatedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._parentCreatedAt = newValue}
    }
    /// Returns true if `parentCreatedAt` has been explicitly set.
    var hasParentCreatedAt: Bool {return _storage._parentCreatedAt != nil}
    /// Clears the value of `parentCreatedAt`. Subsequent reads from it will return its default value.
    mutating func clearParentCreatedAt() {_uniqueStorage()._parentCreatedAt = nil}

    var value: Yorkie_V1_JSONElementSimple {
      get {return _storage._value ?? Yorkie_V1_JSONElementSimple()}
      set {_uniqueStorage()._value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return _storage._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {_uniqueStorage()._value = nil}

    var executedAt: Yorkie_V1_TimeTicket {
      get {return _storage._executedAt ?? Yorkie_V1_TimeTicket()}
      set {_uniqueStorage()._executedAt = newValue}
    }
    /// Returns true if `executedAt` has been explicitly set.
    var hasExecutedAt: Bool {return _storage._executedAt != nil}
    /// Clears the value of `executedAt`. Subsequent reads from it will return its default value.
    mutating func clearExecutedAt() {_uniqueStorage()._executedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct Yorkie_V1_JSONElementSimple {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var createdAt: Yorkie_V1_TimeTicket {
    get {return _createdAt ?? Yorkie_V1_TimeTicket()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var movedAt: Yorkie_V1_TimeTicket {
    get {return _movedAt ?? Yorkie_V1_TimeTicket()}
    set {_movedAt = newValue}
  }
  /// Returns true if `movedAt` has been explicitly set.
  var hasMovedAt: Bool {return self._movedAt != nil}
  /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
  mutating func clearMovedAt() {self._movedAt = nil}

  var removedAt: Yorkie_V1_TimeTicket {
    get {return _removedAt ?? Yorkie_V1_TimeTicket()}
    set {_removedAt = newValue}
  }
  /// Returns true if `removedAt` has been explicitly set.
  var hasRemovedAt: Bool {return self._removedAt != nil}
  /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
  mutating func clearRemovedAt() {self._removedAt = nil}

  var type: Yorkie_V1_ValueType = .null

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
  fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
  fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
}

struct Yorkie_V1_JSONElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var body: Yorkie_V1_JSONElement.OneOf_Body? = nil

  var jsonObject: Yorkie_V1_JSONElement.JSONObject {
    get {
      if case .jsonObject(let v)? = body {return v}
      return Yorkie_V1_JSONElement.JSONObject()
    }
    set {body = .jsonObject(newValue)}
  }

  var jsonArray: Yorkie_V1_JSONElement.JSONArray {
    get {
      if case .jsonArray(let v)? = body {return v}
      return Yorkie_V1_JSONElement.JSONArray()
    }
    set {body = .jsonArray(newValue)}
  }

  var primitive: Yorkie_V1_JSONElement.Primitive {
    get {
      if case .primitive(let v)? = body {return v}
      return Yorkie_V1_JSONElement.Primitive()
    }
    set {body = .primitive(newValue)}
  }

  var text: Yorkie_V1_JSONElement.Text {
    get {
      if case .text(let v)? = body {return v}
      return Yorkie_V1_JSONElement.Text()
    }
    set {body = .text(newValue)}
  }

  var richText: Yorkie_V1_JSONElement.RichText {
    get {
      if case .richText(let v)? = body {return v}
      return Yorkie_V1_JSONElement.RichText()
    }
    set {body = .richText(newValue)}
  }

  var counter: Yorkie_V1_JSONElement.Counter {
    get {
      if case .counter(let v)? = body {return v}
      return Yorkie_V1_JSONElement.Counter()
    }
    set {body = .counter(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Body: Equatable {
    case jsonObject(Yorkie_V1_JSONElement.JSONObject)
    case jsonArray(Yorkie_V1_JSONElement.JSONArray)
    case primitive(Yorkie_V1_JSONElement.Primitive)
    case text(Yorkie_V1_JSONElement.Text)
    case richText(Yorkie_V1_JSONElement.RichText)
    case counter(Yorkie_V1_JSONElement.Counter)

  #if !swift(>=4.1)
    static func ==(lhs: Yorkie_V1_JSONElement.OneOf_Body, rhs: Yorkie_V1_JSONElement.OneOf_Body) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.jsonObject, .jsonObject): return {
        guard case .jsonObject(let l) = lhs, case .jsonObject(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.jsonArray, .jsonArray): return {
        guard case .jsonArray(let l) = lhs, case .jsonArray(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.primitive, .primitive): return {
        guard case .primitive(let l) = lhs, case .primitive(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.richText, .richText): return {
        guard case .richText(let l) = lhs, case .richText(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.counter, .counter): return {
        guard case .counter(let l) = lhs, case .counter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct JSONObject {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodes: [Yorkie_V1_RHTNode] = []

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var movedAt: Yorkie_V1_TimeTicket {
      get {return _movedAt ?? Yorkie_V1_TimeTicket()}
      set {_movedAt = newValue}
    }
    /// Returns true if `movedAt` has been explicitly set.
    var hasMovedAt: Bool {return self._movedAt != nil}
    /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
    mutating func clearMovedAt() {self._movedAt = nil}

    var removedAt: Yorkie_V1_TimeTicket {
      get {return _removedAt ?? Yorkie_V1_TimeTicket()}
      set {_removedAt = newValue}
    }
    /// Returns true if `removedAt` has been explicitly set.
    var hasRemovedAt: Bool {return self._removedAt != nil}
    /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
    mutating func clearRemovedAt() {self._removedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct JSONArray {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodes: [Yorkie_V1_RGANode] = []

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var movedAt: Yorkie_V1_TimeTicket {
      get {return _movedAt ?? Yorkie_V1_TimeTicket()}
      set {_movedAt = newValue}
    }
    /// Returns true if `movedAt` has been explicitly set.
    var hasMovedAt: Bool {return self._movedAt != nil}
    /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
    mutating func clearMovedAt() {self._movedAt = nil}

    var removedAt: Yorkie_V1_TimeTicket {
      get {return _removedAt ?? Yorkie_V1_TimeTicket()}
      set {_removedAt = newValue}
    }
    /// Returns true if `removedAt` has been explicitly set.
    var hasRemovedAt: Bool {return self._removedAt != nil}
    /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
    mutating func clearRemovedAt() {self._removedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct Primitive {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Yorkie_V1_ValueType = .null

    var value: Data = Data()

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var movedAt: Yorkie_V1_TimeTicket {
      get {return _movedAt ?? Yorkie_V1_TimeTicket()}
      set {_movedAt = newValue}
    }
    /// Returns true if `movedAt` has been explicitly set.
    var hasMovedAt: Bool {return self._movedAt != nil}
    /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
    mutating func clearMovedAt() {self._movedAt = nil}

    var removedAt: Yorkie_V1_TimeTicket {
      get {return _removedAt ?? Yorkie_V1_TimeTicket()}
      set {_removedAt = newValue}
    }
    /// Returns true if `removedAt` has been explicitly set.
    var hasRemovedAt: Bool {return self._removedAt != nil}
    /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
    mutating func clearRemovedAt() {self._removedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct Text {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodes: [Yorkie_V1_TextNode] = []

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var movedAt: Yorkie_V1_TimeTicket {
      get {return _movedAt ?? Yorkie_V1_TimeTicket()}
      set {_movedAt = newValue}
    }
    /// Returns true if `movedAt` has been explicitly set.
    var hasMovedAt: Bool {return self._movedAt != nil}
    /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
    mutating func clearMovedAt() {self._movedAt = nil}

    var removedAt: Yorkie_V1_TimeTicket {
      get {return _removedAt ?? Yorkie_V1_TimeTicket()}
      set {_removedAt = newValue}
    }
    /// Returns true if `removedAt` has been explicitly set.
    var hasRemovedAt: Bool {return self._removedAt != nil}
    /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
    mutating func clearRemovedAt() {self._removedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct RichText {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodes: [Yorkie_V1_RichTextNode] = []

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var movedAt: Yorkie_V1_TimeTicket {
      get {return _movedAt ?? Yorkie_V1_TimeTicket()}
      set {_movedAt = newValue}
    }
    /// Returns true if `movedAt` has been explicitly set.
    var hasMovedAt: Bool {return self._movedAt != nil}
    /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
    mutating func clearMovedAt() {self._movedAt = nil}

    var removedAt: Yorkie_V1_TimeTicket {
      get {return _removedAt ?? Yorkie_V1_TimeTicket()}
      set {_removedAt = newValue}
    }
    /// Returns true if `removedAt` has been explicitly set.
    var hasRemovedAt: Bool {return self._removedAt != nil}
    /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
    mutating func clearRemovedAt() {self._removedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  }

  struct Counter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Yorkie_V1_ValueType = .null

    var value: Data = Data()

    var createdAt: Yorkie_V1_TimeTicket {
      get {return _createdAt ?? Yorkie_V1_TimeTicket()}
      set {_createdAt = newValue}
    }
    /// Returns true if `createdAt` has been explicitly set.
    var hasCreatedAt: Bool {return self._createdAt != nil}
    /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
    mutating func clearCreatedAt() {self._createdAt = nil}

    var movedAt: Yorkie_V1_TimeTicket {
      get {return _movedAt ?? Yorkie_V1_TimeTicket()}
      set {_movedAt = newValue}
    }
    /// Returns true if `movedAt` has been explicitly set.
    var hasMovedAt: Bool {return self._movedAt != nil}
    /// Clears the value of `movedAt`. Subsequent reads from it will return its default value.
    mutating func clearMovedAt() {self._movedAt = nil}

    var removedAt: Yorkie_V1_TimeTicket {
      get {return _removedAt ?? Yorkie_V1_TimeTicket()}
      set {_removedAt = newValue}
    }
    /// Returns true if `removedAt` has been explicitly set.
    var hasRemovedAt: Bool {return self._removedAt != nil}
    /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
    mutating func clearRemovedAt() {self._removedAt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _movedAt: Yorkie_V1_TimeTicket? = nil
    fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  }

  init() {}
}

struct Yorkie_V1_RHTNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var element: Yorkie_V1_JSONElement {
    get {return _element ?? Yorkie_V1_JSONElement()}
    set {_element = newValue}
  }
  /// Returns true if `element` has been explicitly set.
  var hasElement: Bool {return self._element != nil}
  /// Clears the value of `element`. Subsequent reads from it will return its default value.
  mutating func clearElement() {self._element = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _element: Yorkie_V1_JSONElement? = nil
}

struct Yorkie_V1_RGANode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var next: Yorkie_V1_RGANode {
    get {return _storage._next ?? Yorkie_V1_RGANode()}
    set {_uniqueStorage()._next = newValue}
  }
  /// Returns true if `next` has been explicitly set.
  var hasNext: Bool {return _storage._next != nil}
  /// Clears the value of `next`. Subsequent reads from it will return its default value.
  mutating func clearNext() {_uniqueStorage()._next = nil}

  var element: Yorkie_V1_JSONElement {
    get {return _storage._element ?? Yorkie_V1_JSONElement()}
    set {_uniqueStorage()._element = newValue}
  }
  /// Returns true if `element` has been explicitly set.
  var hasElement: Bool {return _storage._element != nil}
  /// Clears the value of `element`. Subsequent reads from it will return its default value.
  mutating func clearElement() {_uniqueStorage()._element = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Yorkie_V1_TextNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Yorkie_V1_TextNodeID {
    get {return _id ?? Yorkie_V1_TextNodeID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var value: String = String()

  var removedAt: Yorkie_V1_TimeTicket {
    get {return _removedAt ?? Yorkie_V1_TimeTicket()}
    set {_removedAt = newValue}
  }
  /// Returns true if `removedAt` has been explicitly set.
  var hasRemovedAt: Bool {return self._removedAt != nil}
  /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
  mutating func clearRemovedAt() {self._removedAt = nil}

  var insPrevID: Yorkie_V1_TextNodeID {
    get {return _insPrevID ?? Yorkie_V1_TextNodeID()}
    set {_insPrevID = newValue}
  }
  /// Returns true if `insPrevID` has been explicitly set.
  var hasInsPrevID: Bool {return self._insPrevID != nil}
  /// Clears the value of `insPrevID`. Subsequent reads from it will return its default value.
  mutating func clearInsPrevID() {self._insPrevID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Yorkie_V1_TextNodeID? = nil
  fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  fileprivate var _insPrevID: Yorkie_V1_TextNodeID? = nil
}

struct Yorkie_V1_RichTextNodeAttr {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: String = String()

  var updatedAt: Yorkie_V1_TimeTicket {
    get {return _updatedAt ?? Yorkie_V1_TimeTicket()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updatedAt: Yorkie_V1_TimeTicket? = nil
}

struct Yorkie_V1_RichTextNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Yorkie_V1_TextNodeID {
    get {return _id ?? Yorkie_V1_TextNodeID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var attributes: Dictionary<String,Yorkie_V1_RichTextNodeAttr> = [:]

  var value: String = String()

  var removedAt: Yorkie_V1_TimeTicket {
    get {return _removedAt ?? Yorkie_V1_TimeTicket()}
    set {_removedAt = newValue}
  }
  /// Returns true if `removedAt` has been explicitly set.
  var hasRemovedAt: Bool {return self._removedAt != nil}
  /// Clears the value of `removedAt`. Subsequent reads from it will return its default value.
  mutating func clearRemovedAt() {self._removedAt = nil}

  var insPrevID: Yorkie_V1_TextNodeID {
    get {return _insPrevID ?? Yorkie_V1_TextNodeID()}
    set {_insPrevID = newValue}
  }
  /// Returns true if `insPrevID` has been explicitly set.
  var hasInsPrevID: Bool {return self._insPrevID != nil}
  /// Clears the value of `insPrevID`. Subsequent reads from it will return its default value.
  mutating func clearInsPrevID() {self._insPrevID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Yorkie_V1_TextNodeID? = nil
  fileprivate var _removedAt: Yorkie_V1_TimeTicket? = nil
  fileprivate var _insPrevID: Yorkie_V1_TextNodeID? = nil
}

struct Yorkie_V1_TextNodeID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var createdAt: Yorkie_V1_TimeTicket {
    get {return _createdAt ?? Yorkie_V1_TimeTicket()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var offset: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
}

struct Yorkie_V1_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var username: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Yorkie_V1_Project {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var publicKey: String = String()

  var secretKey: String = String()

  var authWebhookURL: String = String()

  var authWebhookMethods: [String] = []

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Yorkie_V1_UpdatableProjectFields {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _name ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var authWebhookURL: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _authWebhookURL ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_authWebhookURL = newValue}
  }
  /// Returns true if `authWebhookURL` has been explicitly set.
  var hasAuthWebhookURL: Bool {return self._authWebhookURL != nil}
  /// Clears the value of `authWebhookURL`. Subsequent reads from it will return its default value.
  mutating func clearAuthWebhookURL() {self._authWebhookURL = nil}

  var authWebhookMethods: Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods {
    get {return _authWebhookMethods ?? Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods()}
    set {_authWebhookMethods = newValue}
  }
  /// Returns true if `authWebhookMethods` has been explicitly set.
  var hasAuthWebhookMethods: Bool {return self._authWebhookMethods != nil}
  /// Clears the value of `authWebhookMethods`. Subsequent reads from it will return its default value.
  mutating func clearAuthWebhookMethods() {self._authWebhookMethods = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct AuthWebhookMethods {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var methods: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _name: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _authWebhookURL: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _authWebhookMethods: Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods? = nil
}

struct Yorkie_V1_DocumentSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var key: String = String()

  var snapshot: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var accessedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _accessedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_accessedAt = newValue}
  }
  /// Returns true if `accessedAt` has been explicitly set.
  var hasAccessedAt: Bool {return self._accessedAt != nil}
  /// Clears the value of `accessedAt`. Subsequent reads from it will return its default value.
  mutating func clearAccessedAt() {self._accessedAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _accessedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Yorkie_V1_Presence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var clock: Int32 = 0

  var data: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Yorkie_V1_Client {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var presence: Yorkie_V1_Presence {
    get {return _presence ?? Yorkie_V1_Presence()}
    set {_presence = newValue}
  }
  /// Returns true if `presence` has been explicitly set.
  var hasPresence: Bool {return self._presence != nil}
  /// Clears the value of `presence`. Subsequent reads from it will return its default value.
  mutating func clearPresence() {self._presence = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _presence: Yorkie_V1_Presence? = nil
}

struct Yorkie_V1_Clients {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var clients: [Yorkie_V1_Client] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Yorkie_V1_Checkpoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serverSeq: Int64 = 0

  var clientSeq: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Yorkie_V1_TextNodePos {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var createdAt: Yorkie_V1_TimeTicket {
    get {return _createdAt ?? Yorkie_V1_TimeTicket()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var offset: Int32 = 0

  var relativeOffset: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: Yorkie_V1_TimeTicket? = nil
}

struct Yorkie_V1_TimeTicket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lamport: Int64 = 0

  var delimiter: UInt32 = 0

  var actorID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Yorkie_V1_DocEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Yorkie_V1_DocEventType = .documentsChanged

  var publisher: Yorkie_V1_Client {
    get {return _publisher ?? Yorkie_V1_Client()}
    set {_publisher = newValue}
  }
  /// Returns true if `publisher` has been explicitly set.
  var hasPublisher: Bool {return self._publisher != nil}
  /// Clears the value of `publisher`. Subsequent reads from it will return its default value.
  mutating func clearPublisher() {self._publisher = nil}

  var documentKeys: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publisher: Yorkie_V1_Client? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Yorkie_V1_ValueType: @unchecked Sendable {}
extension Yorkie_V1_DocEventType: @unchecked Sendable {}
extension Yorkie_V1_ChangePack: @unchecked Sendable {}
extension Yorkie_V1_Change: @unchecked Sendable {}
extension Yorkie_V1_ChangeID: @unchecked Sendable {}
extension Yorkie_V1_Operation: @unchecked Sendable {}
extension Yorkie_V1_Operation.OneOf_Body: @unchecked Sendable {}
extension Yorkie_V1_Operation.Set: @unchecked Sendable {}
extension Yorkie_V1_Operation.Add: @unchecked Sendable {}
extension Yorkie_V1_Operation.Move: @unchecked Sendable {}
extension Yorkie_V1_Operation.Remove: @unchecked Sendable {}
extension Yorkie_V1_Operation.Edit: @unchecked Sendable {}
extension Yorkie_V1_Operation.Select: @unchecked Sendable {}
extension Yorkie_V1_Operation.RichEdit: @unchecked Sendable {}
extension Yorkie_V1_Operation.Style: @unchecked Sendable {}
extension Yorkie_V1_Operation.Increase: @unchecked Sendable {}
extension Yorkie_V1_JSONElementSimple: @unchecked Sendable {}
extension Yorkie_V1_JSONElement: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.OneOf_Body: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.JSONObject: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.JSONArray: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.Primitive: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.Text: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.RichText: @unchecked Sendable {}
extension Yorkie_V1_JSONElement.Counter: @unchecked Sendable {}
extension Yorkie_V1_RHTNode: @unchecked Sendable {}
extension Yorkie_V1_RGANode: @unchecked Sendable {}
extension Yorkie_V1_TextNode: @unchecked Sendable {}
extension Yorkie_V1_RichTextNodeAttr: @unchecked Sendable {}
extension Yorkie_V1_RichTextNode: @unchecked Sendable {}
extension Yorkie_V1_TextNodeID: @unchecked Sendable {}
extension Yorkie_V1_User: @unchecked Sendable {}
extension Yorkie_V1_Project: @unchecked Sendable {}
extension Yorkie_V1_UpdatableProjectFields: @unchecked Sendable {}
extension Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods: @unchecked Sendable {}
extension Yorkie_V1_DocumentSummary: @unchecked Sendable {}
extension Yorkie_V1_Presence: @unchecked Sendable {}
extension Yorkie_V1_Client: @unchecked Sendable {}
extension Yorkie_V1_Clients: @unchecked Sendable {}
extension Yorkie_V1_Checkpoint: @unchecked Sendable {}
extension Yorkie_V1_TextNodePos: @unchecked Sendable {}
extension Yorkie_V1_TimeTicket: @unchecked Sendable {}
extension Yorkie_V1_DocEvent: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "yorkie.v1"

extension Yorkie_V1_ValueType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VALUE_TYPE_NULL"),
    1: .same(proto: "VALUE_TYPE_BOOLEAN"),
    2: .same(proto: "VALUE_TYPE_INTEGER"),
    3: .same(proto: "VALUE_TYPE_LONG"),
    4: .same(proto: "VALUE_TYPE_DOUBLE"),
    5: .same(proto: "VALUE_TYPE_STRING"),
    6: .same(proto: "VALUE_TYPE_BYTES"),
    7: .same(proto: "VALUE_TYPE_DATE"),
    8: .same(proto: "VALUE_TYPE_JSON_OBJECT"),
    9: .same(proto: "VALUE_TYPE_JSON_ARRAY"),
    10: .same(proto: "VALUE_TYPE_TEXT"),
    11: .same(proto: "VALUE_TYPE_RICH_TEXT"),
    12: .same(proto: "VALUE_TYPE_INTEGER_CNT"),
    13: .same(proto: "VALUE_TYPE_LONG_CNT"),
    14: .same(proto: "VALUE_TYPE_DOUBLE_CNT"),
  ]
}

extension Yorkie_V1_DocEventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DOC_EVENT_TYPE_DOCUMENTS_CHANGED"),
    1: .same(proto: "DOC_EVENT_TYPE_DOCUMENTS_WATCHED"),
    2: .same(proto: "DOC_EVENT_TYPE_DOCUMENTS_UNWATCHED"),
    3: .same(proto: "DOC_EVENT_TYPE_PRESENCE_CHANGED"),
  ]
}

extension Yorkie_V1_ChangePack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangePack"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "document_key"),
    2: .same(proto: "checkpoint"),
    3: .same(proto: "snapshot"),
    4: .same(proto: "changes"),
    5: .standard(proto: "min_synced_ticket"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.documentKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._checkpoint) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.snapshot) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.changes) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._minSyncedTicket) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.documentKey.isEmpty {
      try visitor.visitSingularStringField(value: self.documentKey, fieldNumber: 1)
    }
    try { if let v = self._checkpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.snapshot.isEmpty {
      try visitor.visitSingularBytesField(value: self.snapshot, fieldNumber: 3)
    }
    if !self.changes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changes, fieldNumber: 4)
    }
    try { if let v = self._minSyncedTicket {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_ChangePack, rhs: Yorkie_V1_ChangePack) -> Bool {
    if lhs.documentKey != rhs.documentKey {return false}
    if lhs._checkpoint != rhs._checkpoint {return false}
    if lhs.snapshot != rhs.snapshot {return false}
    if lhs.changes != rhs.changes {return false}
    if lhs._minSyncedTicket != rhs._minSyncedTicket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Change: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Change"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "message"),
    3: .same(proto: "operations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Change, rhs: Yorkie_V1_Change) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.message != rhs.message {return false}
    if lhs.operations != rhs.operations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_ChangeID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_seq"),
    2: .standard(proto: "server_seq"),
    3: .same(proto: "lamport"),
    4: .standard(proto: "actor_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.clientSeq) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.serverSeq) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.lamport) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.actorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clientSeq != 0 {
      try visitor.visitSingularUInt32Field(value: self.clientSeq, fieldNumber: 1)
    }
    if self.serverSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.serverSeq, fieldNumber: 2)
    }
    if self.lamport != 0 {
      try visitor.visitSingularInt64Field(value: self.lamport, fieldNumber: 3)
    }
    if !self.actorID.isEmpty {
      try visitor.visitSingularBytesField(value: self.actorID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_ChangeID, rhs: Yorkie_V1_ChangeID) -> Bool {
    if lhs.clientSeq != rhs.clientSeq {return false}
    if lhs.serverSeq != rhs.serverSeq {return false}
    if lhs.lamport != rhs.lamport {return false}
    if lhs.actorID != rhs.actorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Operation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
    2: .same(proto: "add"),
    3: .same(proto: "move"),
    4: .same(proto: "remove"),
    5: .same(proto: "edit"),
    6: .same(proto: "select"),
    7: .standard(proto: "rich_edit"),
    8: .same(proto: "style"),
    9: .same(proto: "increase"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Yorkie_V1_Operation.Set?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .set(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .set(v)
        }
      }()
      case 2: try {
        var v: Yorkie_V1_Operation.Add?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .add(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .add(v)
        }
      }()
      case 3: try {
        var v: Yorkie_V1_Operation.Move?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .move(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .move(v)
        }
      }()
      case 4: try {
        var v: Yorkie_V1_Operation.Remove?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .remove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .remove(v)
        }
      }()
      case 5: try {
        var v: Yorkie_V1_Operation.Edit?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .edit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .edit(v)
        }
      }()
      case 6: try {
        var v: Yorkie_V1_Operation.Select?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .select(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .select(v)
        }
      }()
      case 7: try {
        var v: Yorkie_V1_Operation.RichEdit?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .richEdit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .richEdit(v)
        }
      }()
      case 8: try {
        var v: Yorkie_V1_Operation.Style?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .style(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .style(v)
        }
      }()
      case 9: try {
        var v: Yorkie_V1_Operation.Increase?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .increase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .increase(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .set?: try {
      guard case .set(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .add?: try {
      guard case .add(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .move?: try {
      guard case .move(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .remove?: try {
      guard case .remove(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .edit?: try {
      guard case .edit(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .select?: try {
      guard case .select(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .richEdit?: try {
      guard case .richEdit(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .style?: try {
      guard case .style(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .increase?: try {
      guard case .increase(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation, rhs: Yorkie_V1_Operation) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Set"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .same(proto: "key"),
    3: .same(proto: "value"),
    4: .standard(proto: "executed_at"),
  ]

  fileprivate class _StorageClass {
    var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _key: String = String()
    var _value: Yorkie_V1_JSONElementSimple? = nil
    var _executedAt: Yorkie_V1_TimeTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parentCreatedAt = source._parentCreatedAt
      _key = source._key
      _value = source._value
      _executedAt = source._executedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._parentCreatedAt) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._key) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._executedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._parentCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 2)
      }
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._executedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Set, rhs: Yorkie_V1_Operation.Set) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parentCreatedAt != rhs_storage._parentCreatedAt {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._executedAt != rhs_storage._executedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Add: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Add"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .standard(proto: "prev_created_at"),
    3: .same(proto: "value"),
    4: .standard(proto: "executed_at"),
  ]

  fileprivate class _StorageClass {
    var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _prevCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _value: Yorkie_V1_JSONElementSimple? = nil
    var _executedAt: Yorkie_V1_TimeTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parentCreatedAt = source._parentCreatedAt
      _prevCreatedAt = source._prevCreatedAt
      _value = source._value
      _executedAt = source._executedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._parentCreatedAt) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._prevCreatedAt) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._executedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._parentCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._prevCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._executedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Add, rhs: Yorkie_V1_Operation.Add) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parentCreatedAt != rhs_storage._parentCreatedAt {return false}
        if _storage._prevCreatedAt != rhs_storage._prevCreatedAt {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._executedAt != rhs_storage._executedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Move: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Move"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .standard(proto: "prev_created_at"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "executed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parentCreatedAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._prevCreatedAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._executedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parentCreatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._prevCreatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._executedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Move, rhs: Yorkie_V1_Operation.Move) -> Bool {
    if lhs._parentCreatedAt != rhs._parentCreatedAt {return false}
    if lhs._prevCreatedAt != rhs._prevCreatedAt {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._executedAt != rhs._executedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Remove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Remove"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "executed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parentCreatedAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._executedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parentCreatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._executedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Remove, rhs: Yorkie_V1_Operation.Remove) -> Bool {
    if lhs._parentCreatedAt != rhs._parentCreatedAt {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._executedAt != rhs._executedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Edit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Edit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "created_at_map_by_actor"),
    5: .same(proto: "content"),
    6: .standard(proto: "executed_at"),
  ]

  fileprivate class _StorageClass {
    var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _from: Yorkie_V1_TextNodePos? = nil
    var _to: Yorkie_V1_TextNodePos? = nil
    var _createdAtMapByActor: Dictionary<String,Yorkie_V1_TimeTicket> = [:]
    var _content: String = String()
    var _executedAt: Yorkie_V1_TimeTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parentCreatedAt = source._parentCreatedAt
      _from = source._from
      _to = source._to
      _createdAtMapByActor = source._createdAtMapByActor
      _content = source._content
      _executedAt = source._executedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._parentCreatedAt) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._from) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._to) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_TimeTicket>.self, value: &_storage._createdAtMapByActor) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._executedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._parentCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._from {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._to {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._createdAtMapByActor.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_TimeTicket>.self, value: _storage._createdAtMapByActor, fieldNumber: 4)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 5)
      }
      try { if let v = _storage._executedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Edit, rhs: Yorkie_V1_Operation.Edit) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parentCreatedAt != rhs_storage._parentCreatedAt {return false}
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._createdAtMapByActor != rhs_storage._createdAtMapByActor {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._executedAt != rhs_storage._executedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Select: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Select"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "executed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parentCreatedAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._executedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parentCreatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._executedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Select, rhs: Yorkie_V1_Operation.Select) -> Bool {
    if lhs._parentCreatedAt != rhs._parentCreatedAt {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs._executedAt != rhs._executedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.RichEdit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".RichEdit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "created_at_map_by_actor"),
    5: .same(proto: "content"),
    6: .same(proto: "attributes"),
    7: .standard(proto: "executed_at"),
  ]

  fileprivate class _StorageClass {
    var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _from: Yorkie_V1_TextNodePos? = nil
    var _to: Yorkie_V1_TextNodePos? = nil
    var _createdAtMapByActor: Dictionary<String,Yorkie_V1_TimeTicket> = [:]
    var _content: String = String()
    var _attributes: Dictionary<String,String> = [:]
    var _executedAt: Yorkie_V1_TimeTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parentCreatedAt = source._parentCreatedAt
      _from = source._from
      _to = source._to
      _createdAtMapByActor = source._createdAtMapByActor
      _content = source._content
      _attributes = source._attributes
      _executedAt = source._executedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._parentCreatedAt) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._from) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._to) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_TimeTicket>.self, value: &_storage._createdAtMapByActor) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._attributes) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._executedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._parentCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._from {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._to {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._createdAtMapByActor.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_TimeTicket>.self, value: _storage._createdAtMapByActor, fieldNumber: 4)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 5)
      }
      if !_storage._attributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._attributes, fieldNumber: 6)
      }
      try { if let v = _storage._executedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.RichEdit, rhs: Yorkie_V1_Operation.RichEdit) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parentCreatedAt != rhs_storage._parentCreatedAt {return false}
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._createdAtMapByActor != rhs_storage._createdAtMapByActor {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._executedAt != rhs_storage._executedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Style: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Style"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "attributes"),
    5: .standard(proto: "executed_at"),
  ]

  fileprivate class _StorageClass {
    var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _from: Yorkie_V1_TextNodePos? = nil
    var _to: Yorkie_V1_TextNodePos? = nil
    var _attributes: Dictionary<String,String> = [:]
    var _executedAt: Yorkie_V1_TimeTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parentCreatedAt = source._parentCreatedAt
      _from = source._from
      _to = source._to
      _attributes = source._attributes
      _executedAt = source._executedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._parentCreatedAt) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._from) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._to) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._attributes) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._executedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._parentCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._from {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._to {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._attributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._attributes, fieldNumber: 4)
      }
      try { if let v = _storage._executedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Style, rhs: Yorkie_V1_Operation.Style) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parentCreatedAt != rhs_storage._parentCreatedAt {return false}
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._executedAt != rhs_storage._executedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Operation.Increase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_Operation.protoMessageName + ".Increase"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_created_at"),
    2: .same(proto: "value"),
    3: .standard(proto: "executed_at"),
  ]

  fileprivate class _StorageClass {
    var _parentCreatedAt: Yorkie_V1_TimeTicket? = nil
    var _value: Yorkie_V1_JSONElementSimple? = nil
    var _executedAt: Yorkie_V1_TimeTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parentCreatedAt = source._parentCreatedAt
      _value = source._value
      _executedAt = source._executedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._parentCreatedAt) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._executedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._parentCreatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._executedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Operation.Increase, rhs: Yorkie_V1_Operation.Increase) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parentCreatedAt != rhs_storage._parentCreatedAt {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._executedAt != rhs_storage._executedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElementSimple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JSONElementSimple"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_at"),
    2: .standard(proto: "moved_at"),
    3: .standard(proto: "removed_at"),
    4: .same(proto: "type"),
    5: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.type != .null {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElementSimple, rhs: Yorkie_V1_JSONElementSimple) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JSONElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "json_object"),
    2: .standard(proto: "json_array"),
    3: .same(proto: "primitive"),
    4: .same(proto: "text"),
    5: .standard(proto: "rich_text"),
    6: .same(proto: "counter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Yorkie_V1_JSONElement.JSONObject?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .jsonObject(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .jsonObject(v)
        }
      }()
      case 2: try {
        var v: Yorkie_V1_JSONElement.JSONArray?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .jsonArray(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .jsonArray(v)
        }
      }()
      case 3: try {
        var v: Yorkie_V1_JSONElement.Primitive?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .primitive(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .primitive(v)
        }
      }()
      case 4: try {
        var v: Yorkie_V1_JSONElement.Text?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .text(v)
        }
      }()
      case 5: try {
        var v: Yorkie_V1_JSONElement.RichText?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .richText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .richText(v)
        }
      }()
      case 6: try {
        var v: Yorkie_V1_JSONElement.Counter?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .counter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .counter(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .jsonObject?: try {
      guard case .jsonObject(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .jsonArray?: try {
      guard case .jsonArray(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .primitive?: try {
      guard case .primitive(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .text?: try {
      guard case .text(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .richText?: try {
      guard case .richText(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .counter?: try {
      guard case .counter(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement, rhs: Yorkie_V1_JSONElement) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement.JSONObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_JSONElement.protoMessageName + ".JSONObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "moved_at"),
    4: .standard(proto: "removed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement.JSONObject, rhs: Yorkie_V1_JSONElement.JSONObject) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement.JSONArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_JSONElement.protoMessageName + ".JSONArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "moved_at"),
    4: .standard(proto: "removed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement.JSONArray, rhs: Yorkie_V1_JSONElement.JSONArray) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement.Primitive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_JSONElement.protoMessageName + ".Primitive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "moved_at"),
    5: .standard(proto: "removed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .null {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement.Primitive, rhs: Yorkie_V1_JSONElement.Primitive) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_JSONElement.protoMessageName + ".Text"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "moved_at"),
    4: .standard(proto: "removed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement.Text, rhs: Yorkie_V1_JSONElement.Text) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement.RichText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_JSONElement.protoMessageName + ".RichText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "moved_at"),
    4: .standard(proto: "removed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement.RichText, rhs: Yorkie_V1_JSONElement.RichText) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_JSONElement.Counter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_JSONElement.protoMessageName + ".Counter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "moved_at"),
    5: .standard(proto: "removed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._movedAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .null {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._movedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_JSONElement.Counter, rhs: Yorkie_V1_JSONElement.Counter) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._movedAt != rhs._movedAt {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_RHTNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RHTNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "element"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._element) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try { if let v = self._element {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_RHTNode, rhs: Yorkie_V1_RHTNode) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._element != rhs._element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_RGANode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RGANode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "next"),
    2: .same(proto: "element"),
  ]

  fileprivate class _StorageClass {
    var _next: Yorkie_V1_RGANode? = nil
    var _element: Yorkie_V1_JSONElement? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _next = source._next
      _element = source._element
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._next) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._element) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._next {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._element {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_RGANode, rhs: Yorkie_V1_RGANode) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._next != rhs_storage._next {return false}
        if _storage._element != rhs_storage._element {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_TextNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "value"),
    3: .standard(proto: "removed_at"),
    4: .standard(proto: "ins_prev_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._insPrevID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._insPrevID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_TextNode, rhs: Yorkie_V1_TextNode) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.value != rhs.value {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs._insPrevID != rhs._insPrevID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_RichTextNodeAttr: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RichTextNodeAttr"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_RichTextNodeAttr, rhs: Yorkie_V1_RichTextNodeAttr) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_RichTextNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RichTextNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "attributes"),
    3: .same(proto: "value"),
    4: .standard(proto: "removed_at"),
    5: .standard(proto: "ins_prev_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_RichTextNodeAttr>.self, value: &self.attributes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._removedAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._insPrevID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Yorkie_V1_RichTextNodeAttr>.self, value: self.attributes, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try { if let v = self._removedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._insPrevID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_RichTextNode, rhs: Yorkie_V1_RichTextNode) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.value != rhs.value {return false}
    if lhs._removedAt != rhs._removedAt {return false}
    if lhs._insPrevID != rhs._insPrevID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_TextNodeID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextNodeID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_at"),
    2: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_TextNodeID, rhs: Yorkie_V1_TextNodeID) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "username"),
    3: .standard(proto: "created_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_User, rhs: Yorkie_V1_User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.username != rhs.username {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Project: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Project"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "public_key"),
    4: .standard(proto: "secret_key"),
    5: .standard(proto: "auth_webhook_url"),
    6: .standard(proto: "auth_webhook_methods"),
    7: .standard(proto: "created_at"),
    8: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.secretKey) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authWebhookURL) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.authWebhookMethods) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 3)
    }
    if !self.secretKey.isEmpty {
      try visitor.visitSingularStringField(value: self.secretKey, fieldNumber: 4)
    }
    if !self.authWebhookURL.isEmpty {
      try visitor.visitSingularStringField(value: self.authWebhookURL, fieldNumber: 5)
    }
    if !self.authWebhookMethods.isEmpty {
      try visitor.visitRepeatedStringField(value: self.authWebhookMethods, fieldNumber: 6)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Project, rhs: Yorkie_V1_Project) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.secretKey != rhs.secretKey {return false}
    if lhs.authWebhookURL != rhs.authWebhookURL {return false}
    if lhs.authWebhookMethods != rhs.authWebhookMethods {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_UpdatableProjectFields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdatableProjectFields"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "auth_webhook_url"),
    3: .standard(proto: "auth_webhook_methods"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authWebhookURL) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._authWebhookMethods) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authWebhookURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._authWebhookMethods {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_UpdatableProjectFields, rhs: Yorkie_V1_UpdatableProjectFields) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._authWebhookURL != rhs._authWebhookURL {return false}
    if lhs._authWebhookMethods != rhs._authWebhookMethods {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Yorkie_V1_UpdatableProjectFields.protoMessageName + ".AuthWebhookMethods"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "methods"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.methods) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.methods.isEmpty {
      try visitor.visitRepeatedStringField(value: self.methods, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods, rhs: Yorkie_V1_UpdatableProjectFields.AuthWebhookMethods) -> Bool {
    if lhs.methods != rhs.methods {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_DocumentSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "key"),
    3: .same(proto: "snapshot"),
    4: .standard(proto: "created_at"),
    5: .standard(proto: "accessed_at"),
    6: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.snapshot) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._accessedAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.snapshot.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshot, fieldNumber: 3)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._accessedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_DocumentSummary, rhs: Yorkie_V1_DocumentSummary) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.key != rhs.key {return false}
    if lhs.snapshot != rhs.snapshot {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._accessedAt != rhs._accessedAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Presence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Presence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clock"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.clock) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clock != 0 {
      try visitor.visitSingularInt32Field(value: self.clock, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Presence, rhs: Yorkie_V1_Presence) -> Bool {
    if lhs.clock != rhs.clock {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Client: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Client"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "presence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._presence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._presence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Client, rhs: Yorkie_V1_Client) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._presence != rhs._presence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Clients: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Clients"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clients"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.clients) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clients.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clients, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Clients, rhs: Yorkie_V1_Clients) -> Bool {
    if lhs.clients != rhs.clients {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_Checkpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Checkpoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_seq"),
    2: .standard(proto: "client_seq"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.serverSeq) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.clientSeq) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.serverSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.serverSeq, fieldNumber: 1)
    }
    if self.clientSeq != 0 {
      try visitor.visitSingularUInt32Field(value: self.clientSeq, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_Checkpoint, rhs: Yorkie_V1_Checkpoint) -> Bool {
    if lhs.serverSeq != rhs.serverSeq {return false}
    if lhs.clientSeq != rhs.clientSeq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_TextNodePos: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextNodePos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_at"),
    2: .same(proto: "offset"),
    3: .standard(proto: "relative_offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.relativeOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 2)
    }
    if self.relativeOffset != 0 {
      try visitor.visitSingularInt32Field(value: self.relativeOffset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_TextNodePos, rhs: Yorkie_V1_TextNodePos) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.relativeOffset != rhs.relativeOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_TimeTicket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeTicket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lamport"),
    2: .same(proto: "delimiter"),
    3: .standard(proto: "actor_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.lamport) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.delimiter) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.actorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lamport != 0 {
      try visitor.visitSingularInt64Field(value: self.lamport, fieldNumber: 1)
    }
    if self.delimiter != 0 {
      try visitor.visitSingularUInt32Field(value: self.delimiter, fieldNumber: 2)
    }
    if !self.actorID.isEmpty {
      try visitor.visitSingularBytesField(value: self.actorID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_TimeTicket, rhs: Yorkie_V1_TimeTicket) -> Bool {
    if lhs.lamport != rhs.lamport {return false}
    if lhs.delimiter != rhs.delimiter {return false}
    if lhs.actorID != rhs.actorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Yorkie_V1_DocEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "publisher"),
    3: .standard(proto: "document_keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publisher) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.documentKeys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .documentsChanged {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._publisher {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.documentKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.documentKeys, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Yorkie_V1_DocEvent, rhs: Yorkie_V1_DocEvent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._publisher != rhs._publisher {return false}
    if lhs.documentKeys != rhs.documentKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
